{"version":3,"sources":["components/WelcomeBanner.js","contexts/actions.js","contexts/page_names.js","contexts/field_defaults/func_group_data.js","contexts/FuncContext.js","components/forms/defaults/func_group_data.js","utils/standards.js","utils/ornaments.js","components/forms/defaults/monomer_data.js","utils/helpers.js","utils/validators.js","utils/FuncGroup.js","components/forms/FuncGroupForm.js","utils/Monomer.js","utils/data_sorting.js","utils/func_calculations.js","components/forms/MonomerForm.js","components/FinalResults.js","pages/Main.js","App.js","index.js"],"names":["WelcomeBanner","className","UPDATE_FUNC","UPDATE_MONOMERS","INITIALIZE_MONOMERS","FUNC_FORM","MONOMER_FORM","FINAL_RESULTS","FUNC_FORM_FIELDS","funcA_name","funcA_num","funcB_name","funcB_num","func_xs","xsGroup","isExcessEQ","FuncContext","React","createContext","FuncDispatchContext","useFuncGroups","useContext","useFuncDispatch","formReducer","formData","formType","formField","value","updatedFuncData","funcGroupsForm","undefined","monomersForm","prevMonomersForm","prevField","prevFieldValue","updatedMonomerData","Error","funcReducer","funcData","type","funcGroups","monomers","funcA","funcB","monomersA","monomersB","setMonomers","pageReducer","current_page","page","initialFunc","FuncProvider","children","useReducer","setFormData","setFuncGroup","setPage","Provider","DEFAULT_FUNC_GROUP_DATA","letter","name_placeholder","num_placeholder","REQUIRED_FUNC_FIELDS","INVALID_PLACEHOLDER","ERROR_TOLERANCE","capitalizeFirstLetter","string_value","length","charAt","toUpperCase","slice","console","log","String","error","GENERATE_MONOMER_FORM_FIELDS","monomerFormFields","funcGroup","num","funcName","name","i","typeErrorMessage","expected_type","received_type","value_name","TypeError","invalidErrorMessage","condition_failed","checkDataTypes","data_type","data","indexAcceptable","index","index_end","index_isInteger","index_inBounds","index_ltz_error","index_bnd_error","index_error","intAcceptable","int_ltz_error","int_inv_error","nameAcceptable","string_bst_error","string_inv_error","floatAcceptable","isMonomer","float_ltz_error","float_inv_error","compareFloatValues","reference_value","comparison_value","error_tolerance","referenceIsFloat","comparisonIsFloat","startingMonomerStatCount","mass","percent","determined","partial","FuncGroup","percent_type","molar_eq","unknown","setIsReference","reference_state","isReference","hasUnknown","monomer_stat","monomerStatCount","determineMonomerStatCount","forEach","monomer","massGiven","percentGiven","weightPercentGiven","molePercentGiven","findRefMonomer","refMonomerFound","sumMonomerStat","reduce","statSum","statValue","getPercentType","getName","getNum","getMolarEQ","getMonomers","index_isValid","getIsReference","getUnknown","getMonomerStatCount","stat_name","setUnknown","unknown_monomer_index","clearMonomers","this","property_name","Array","numMonomersGiven","FuncGroupForm","handleFormChange","event","target","handleFormSubmission","var1","var2","PERCENT_TYPE","document","getElementById","checked","toLowerCase","xs_A_selected","xs_B_selected","molar_eq_is_checked","inputsAcceptable","parsedFuncGroups","map","parseInt","parseFloat","numAcceptable","molar_eqAcceptable","isOK","ERROR_MESSAGE","message","validFuncGroups","validatedFuncGroups","push","useEffect","funcContextUpdated","monomerFieldsGenerated","numReqFieldsNotFilled","field","fieldIsRequired","fieldValue","id","defaultChecked","onChange","placeholder","onClick","func_letter","num_field_name","current_value","Math","floor","subtractMonomerNum","tabIndex","addMonomerNum","EXPECTED_TYPE","Number","Monomer","wpercent","mpercent","molar_mass","moles","getMass","getWeightPercent","getMolePercent","getMolarMass","getMoles","setMass","mass_value","setWeightPercent","wpercent_value","setMolePercent","mpercent_value","setMolarMass","molar_mass_value","setMoles","moles_value","display","monomer_property","property_value","format_options","notation","maximumSignificantDigits","improveScientificNotation","Intl","NumberFormat","format","SIG_FIG","invalid_monomer_property","scientific_value","base_ten","fromCodePoint","split","coefficient","exponent","findRoute","excess_info","zpr_possible","funcNum","funcIsReference","massCount","percentCount","determinedCount","partialCount","mass_present","percent_present","all_percent","almost_all_mass","almost_all_percent","tetris_possible","doReferenceCalculations","refGroup","calculation_route","mass_sum","mol_sum","ref_allMass","percent_sum","g_per_percent","ref_wtpZipper","mol_per_percent","ref_mlpZipper","ref_monomer","part_percent_sum","unknown_monomer","unknown_wpercent","unknown_mass","unknown_moles","ref_xsWeight","reference_moles","unknown_mpercent","ref_xsMole","doComplimentaryCalculations","compGroup","wtp_proportion_sum","wtp_proportions","wtp_proportion","proportion_index","comp_mol_sum","comp_allPercent","part_mol_sum","comp_givenMass","calc_mol_sum","comp_mlpZipper","unknown_mol_offset","percent_contribution_to_mol_sum","all_non_mass_mol_contribution","calc_mass_sum","comp_wtpZipper","xsInfo_validateMasses","calc_complete","calc_failed","determined_comonomers","filter","reference_monomer","reference_ratio","part_mlp_sum","comp_mlpXS","part_wtp_sum","user_mol_sum","comp_wtpXS","ALL_MASSES_GIVEN","NO_PERCENT_GIVEN","routes","funcA_statCount","funcB_statCount","funcA_massCount","funcA_percentCount","funcB_massCount","funcB_percentCount","funcA_canBeReference","funcB_canBeReference","funcA_xsKnowns","funcB_xsKnowns","funcA_massProportion","funcB_massProportion","funcA_route","funcB_route","startDataSorting","from","htmlFor","disabled","parsedMonomers","funcGroupIndex","funcGroupMonomers","unknownCount","percentsGiven","percentSum","monomerName","given_mass","given_percent","given_molar_mass","massAcceptable","percentAcceptable","molar_massAcceptable","weight_percent","mole_percent","percentsSumValid","validateMonomers","validatedMonomers","monomersFuncA","monomersFuncB","validMonomersFuncA","validMonomersFuncB","validMonomers","funcA_monomersOK","funcB_monomersOK","FinalResults","funcA_monomersReset","funcB_monomersReset","monomer_num","handlePageChange","selected_page","Main","App","ReactDOM","createRoot","render","StrictMode"],"mappings":"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","file":"static/js/main.b8f1558c.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nexport default function WelcomeBanner()\r\n{\r\n    return (\r\n        <section className=\"welcome_banner\">\r\n            <h1>Copoly-Calc</h1>\r\n            <p>\r\n                Welcome to Copoly-Calc!<br />\r\n                Copoly-Calc (name not final) is a work-in-progress web application designed to perform copolymerization calculations with minimal user input.<br />\r\n                'Minimal user input' requires that:\r\n            </p>\r\n            <section className=\"explanation\">\r\n                <h3>For both Functional Groups</h3>\r\n                <ol>\r\n                    <li>A unique name must be given</li>\r\n                    <li>Number of comonomers must be given</li>\r\n                    <li>Molar mass for all comonomers must be given</li>\r\n                    <li>A percent type (weight or mole) must be chosen</li>\r\n                    <li>There can only be up to one unknown comonomer (neither mass nor percent being given) for each group</li>\r\n                </ol>\r\n        \r\n                <h3>For Reference Group</h3>\r\n                <ol>\r\n                    <li>At least one comonomer's mass must be given</li>\r\n                    <li>The number of values given for mass and percent combined must be greater than or equal to <em>n</em></li>\r\n                </ol>\r\n        \r\n                <h3>For Complimentary Group</h3>\r\n                <ol>\r\n                    <li>The number of values given for mass and percent combined must be greater than or equal to <em>n - 1</em></li>\r\n                </ol>\r\n        \r\n                <aside>\r\n                    <em>n</em> - Number of comonomers given for an individual functional group.\r\n                </aside>\r\n            </section>\r\n        </section>\r\n    );\r\n}","export const UPDATE_FUNC = 'UPDATE_FUNC';\r\nexport const UPDATE_MONOMERS = 'UPDATE_MONOMERS';\r\nexport const INITIALIZE_MONOMERS = 'INITIALIZE_MONOMERS';","export const FUNC_FORM = 'FUNC_FORM';\r\nexport const MONOMER_FORM = 'MONOMER_FORM';\r\nexport const FINAL_RESULTS = 'FINAL_RESULTS';","\r\n// Starting values for Functional Group Form\r\nexport const FUNC_FORM_FIELDS =\r\n{\r\n    // Functional Group A Form Fields\r\n    funcA_name: '', funcA_num: '',\r\n    // Functional Group B Form Fields\r\n    funcB_name: '', funcB_num: '', \r\n    // Unique Form fields\r\n    func_xs: '', xsGroup: '', isExcessEQ: false\r\n};","import React, { useContext, useReducer } from 'react';\r\nimport { UPDATE_FUNC, INITIALIZE_MONOMERS, UPDATE_MONOMERS } from './actions';\r\nimport { FUNC_FORM, MONOMER_FORM, FINAL_RESULTS } from './page_names';\r\n// Import Functional Group Starting Fields\r\nimport { FUNC_FORM_FIELDS } from './field_defaults/func_group_data';\r\n\r\nconst FuncContext = React.createContext(null);\r\nconst FuncDispatchContext = React.createContext(null);\r\n\r\nexport const useFuncGroups = () => useContext(FuncContext);\r\nexport const useFuncDispatch = () => useContext(FuncDispatchContext);\r\n\r\nfunction formReducer(formData, { formType, formField, value })\r\n{\r\n    switch (formType)\r\n    {\r\n        case FUNC_FORM:\r\n            const updatedFuncData = { ...formData.funcGroupsForm, [formField]: value };\r\n            return { ...formData, funcGroupsForm: updatedFuncData };\r\n\r\n        case INITIALIZE_MONOMERS:\r\n            const { monomersForm } = formData;\r\n\r\n            if (monomersForm === undefined) {\r\n                // This is the first time the monomersForm has been initialized\r\n                formData.monomersForm = value;\r\n                return formData;\r\n            }\r\n            else {\r\n                const { monomersForm: prevMonomersForm } = formData;\r\n                \r\n                // Iterate previous fields over given value for new monomer form fields\r\n                for (let prevField in prevMonomersForm)\r\n                {\r\n                    const prevFieldValue = prevMonomersForm[prevField];\r\n                    // Check if the previous field appears in the new one, and set it to the previous value if so\r\n                    if (value[prevField] !== undefined)\r\n                        value[prevField] = prevFieldValue;\r\n                }\r\n\r\n                return { ...formData, monomersForm: value };\r\n            }\r\n\r\n        case MONOMER_FORM:\r\n            const updatedMonomerData = { ...formData.monomersForm, [formField]: value };\r\n            return { ...formData, monomersForm: updatedMonomerData };\r\n\r\n        default:\r\n            throw Error('Invalid form type: ', formType);\r\n    }\r\n}\r\n\r\nfunction funcReducer(funcData, { type, funcGroups })\r\n{\r\n    switch (type)\r\n    {\r\n        case UPDATE_FUNC:\r\n            return funcGroups;\r\n        \r\n        case UPDATE_MONOMERS:\r\n            const { monomers } = funcGroups;\r\n            \r\n            const [funcA, funcB ] = funcData;\r\n            const [ monomersA, monomersB ] = monomers;\r\n            \r\n            // Add the monomers to functional groups A and B\r\n            funcA.setMonomers(monomersA);\r\n            funcB.setMonomers(monomersB);\r\n            \r\n            return [funcA, funcB];\r\n\r\n        default:\r\n            throw Error('Invalid action: ', type);\r\n    }\r\n}\r\n\r\nfunction pageReducer(current_page, { page })\r\n{\r\n    // Only switch page if the selected page does not match the current page\r\n    if (current_page !== page)\r\n    {\r\n       switch (page)\r\n        {\r\n            case FUNC_FORM:\r\n            case MONOMER_FORM:\r\n            case FINAL_RESULTS:\r\n                return page;\r\n            default:\r\n                throw Error('Invalid page: ', page);\r\n        } \r\n    }\r\n    \r\n    return current_page;\r\n}\r\n\r\nconst initialFunc = [];\r\n\r\nexport default function FuncProvider({ children })\r\n{\r\n    // Tracks Form Data so that it persists between page renders\r\n    const [formData, setFormData] = useReducer(formReducer, { funcGroupsForm: FUNC_FORM_FIELDS });\r\n    // Initial state for functional groups and monomers\r\n    const [funcGroups, setFuncGroup] = useReducer(funcReducer, initialFunc);\r\n    // Tracks which form/page should be displayed\r\n    const [page, setPage] = useReducer(pageReducer, FUNC_FORM);\r\n\r\n    return (\r\n        <FuncContext.Provider value={{ formData, funcGroups, page }} >\r\n            <FuncDispatchContext.Provider value={{ setFormData, setFuncGroup, setPage }} >\r\n                {children}\r\n            </FuncDispatchContext.Provider>\r\n        </FuncContext.Provider>\r\n    );\r\n}","\r\nexport const DEFAULT_FUNC_GROUP_DATA =\r\n[\r\n    // Functional Group A\r\n    {\r\n        letter: 'A',\r\n        name_placeholder: 'diester',\r\n        num_placeholder: 1,\r\n    },\r\n    // Functional Group B\r\n    {\r\n        letter: 'B',\r\n        name_placeholder: 'diol',\r\n        num_placeholder: 2,\r\n    }\r\n];\r\n\r\nexport const REQUIRED_FUNC_FIELDS = \r\n{\r\n    // Functional Group A Form Fields\r\n    funcA_name: true, funcA_num: true,\r\n    // Functional Group B Form Fields\r\n    funcB_name: true, funcB_num: true, \r\n    // Unique Form fields\r\n    func_xs: false, xsGroup: false, isExcessEQ: false\r\n}","\r\n// Number of significant figures for displayed real numbers\r\nexport const SIG_FIG = 4;\r\n\r\n// Placeholder for invalid values that expect to return string value\r\nexport const INVALID_PLACEHOLDER = '[INVALID]';\r\n\r\n// Tolerance for comparing float values\r\nexport const ERROR_TOLERANCE = 0.0001;","import { INVALID_PLACEHOLDER } from \"./standards\";\r\n\r\nexport function capitalizeFirstLetter (string_value) \r\n{\r\n    try {\r\n        if (string_value.length > 1) {\r\n            return string_value.charAt(0).toUpperCase() + string_value.slice(1);\r\n        } else if (string_value.length === 1) {\r\n            return string_value.charAt(0).toUpperCase();\r\n        } else {\r\n            console.log(`Your input value of (${string_value}) is not a string datatype. Its return value will be converted to a string.`);\r\n            return String(string_value);\r\n        }\r\n    }\r\n    catch (error) {\r\n        console.error(error);\r\n        return INVALID_PLACEHOLDER;\r\n    }\r\n}\r\n","import { capitalizeFirstLetter } from '../../../utils/ornaments';\r\n\r\nexport function GENERATE_MONOMER_FORM_FIELDS (funcGroups) \r\n{\r\n    let monomerFormFields = {};\r\n\r\n    for (const funcGroup of funcGroups)\r\n    {\r\n        const { num, name } = funcGroup;\r\n        const funcName = capitalizeFirstLetter(name);\r\n\r\n        // Generate field properties for each comonomer identified by its name (e.g. massDiol-1)\r\n        for (let i = 0 ; i < num ; i++)\r\n        {\r\n            monomerFormFields[`mass${funcName}-${i + 1}`] = '';\r\n            monomerFormFields[`percent${funcName}-${i + 1}`] = '';\r\n            monomerFormFields[`molar_mass${funcName}-${i + 1}`] = '';\r\n        }\r\n    }\r\n    \r\n    return monomerFormFields;\r\n}","\r\n/**\r\n * @param {String} expected_type - Expected datatype name\r\n * @param {String} received_type - Received datatype name\r\n * @param {String} value_name - Name of incorrectly set field\r\n * @returns `TypeError` object with an automatically set error message using the function parameters\r\n */\r\nconst typeErrorMessage = (expected_type, received_type, value_name) => new TypeError(`Expected (${expected_type}) for ${value_name}, received (${received_type})`);\r\n\r\n/**\r\n * @param {String} condition_failed - A description of the failed condition\r\n * @param {String} value_name - Name of incorrectly set field\r\n * @returns `Error` object with an automatically set error message using the function parameters\r\n */\r\nconst invalidErrorMessage = (condition_failed, value_name) => new Error(`(${value_name}) must be \"${condition_failed}\"`);\r\n\r\nexport { typeErrorMessage, invalidErrorMessage }","import { typeErrorMessage, invalidErrorMessage } from \"./helpers\";\r\n\r\n/**\r\n * \r\n * @param {string} data_type - Identifies which datatype to check of three options: 'int', 'string', and 'float'\r\n * @param {object} data - An object which must contain a `value` property (the value to be checked) \r\n * and an `isMonomer` property which is required when checking 'float' values\r\n * @returns A boolean which indicates whether the data matches the expected datatype\r\n */\r\nfunction checkDataTypes(data_type, data) {\r\n    const { value } = data;\r\n\r\n    switch (data_type) {\r\n        case 'index':\r\n            console.log(\"checking index value...\");\r\n            var indexAcceptable;\r\n\r\n            const { value: index, index_end } = data;\r\n            const index_isInteger = index % 1 === 0 && index >= 0;\r\n            const index_inBounds = index <= index_end\r\n\r\n            if (index_isInteger && index_inBounds) {\r\n                // The input value is a positive, whole number within the set bounds, therefore it is acceptable\r\n                indexAcceptable = true;\r\n            }\r\n            else if (!index_isInteger && index_inBounds) {\r\n                const index_ltz_error = invalidErrorMessage('greater than or equal to 0', 'Index');\r\n                console.error(index_ltz_error);\r\n                indexAcceptable = false;\r\n            }\r\n            else if (index_isInteger && !index_inBounds) {\r\n                const index_bnd_error = invalidErrorMessage(`within bounds of array (0-${index_end})`, 'Index');\r\n                console.error(index_bnd_error);\r\n                indexAcceptable = false;\r\n            }\r\n            else {\r\n                const index_error = Error(`Index must be a valid index value and within bounds of array (0-${index_end})`);\r\n                console.error(index_error);\r\n                indexAcceptable = false;\r\n            }\r\n\r\n            return indexAcceptable;\r\n\r\n        case 'int':     // Integer Checker\r\n            console.log(\"checking integer value...\");\r\n            var intAcceptable;\r\n\r\n            if (value <= 0) {\r\n                const int_ltz_error = invalidErrorMessage('greater than 0', 'Integer');\r\n                console.error(int_ltz_error);\r\n                intAcceptable = false;\r\n            } else if (value > 0 && value % 1 === 0) {\r\n                // The input value is a positive non-zero number that it is a whole number, therefore it is acceptable\r\n                intAcceptable = true;\r\n            } else {\r\n                const int_inv_error = typeErrorMessage(data_type, typeof value, 'integer value');\r\n                console.error(int_inv_error);\r\n                intAcceptable = false;\r\n            }\r\n\r\n            return intAcceptable;\r\n\r\n        case 'string':  // String Checker\r\n            console.log(\"checking string value...\");\r\n\r\n            var nameAcceptable;\r\n            \r\n            if (value === \"\") {\r\n                const string_bst_error = invalidErrorMessage('a non-blank string', 'Functional group name');\r\n                console.error(string_bst_error);\r\n                nameAcceptable = false;\r\n            } else if (typeof value === 'string') {\r\n                // The input value is a non-blank string, therefore it is acceptable\r\n                nameAcceptable = true;\r\n            } else {\r\n                const string_inv_error = typeErrorMessage(data_type, typeof value, 'Functional group name');\r\n                console.error(string_inv_error);\r\n                nameAcceptable = false;\r\n            }\r\n            \r\n            return nameAcceptable;\r\n\r\n        case 'float':   // Float Checker\r\n            console.log(\"checking float value...\");\r\n\r\n            const { isMonomer } = data;\r\n            var floatAcceptable;\r\n\r\n            if (value < 0) {\r\n                const float_ltz_error = invalidErrorMessage('greater than 0', 'Float');\r\n                console.error(float_ltz_error);\r\n                floatAcceptable = false;\r\n            } else if (value === 0 && isMonomer) {\r\n                // If the value being checked is for a monomer, a value of 0 is acceptable\r\n                floatAcceptable = true;\r\n            } else if (value > 0) {\r\n                // The input value is a positive non-zero number, therefore it is acceptable\r\n                floatAcceptable = true;\r\n            } else {\r\n                const float_inv_error = typeErrorMessage(data_type, typeof value, 'float value');\r\n                console.error(float_inv_error);\r\n                floatAcceptable = false;\r\n            }\r\n\r\n            return floatAcceptable;\r\n\r\n        default:\r\n            // An invalid datatype was selected\r\n            invalidErrorMessage('an integer, string, or float', data_type);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction checkParity(var1, var2) {\r\n    if (var1 === var2) {\r\n        return true;\r\n    } else if (var1 !== var2) {\r\n        return false;\r\n    } else {\r\n        console.error(\"There was a problem checking parity between var1: \" + var1 + \" and var2: \" + var2);\r\n    }\r\n}\r\n\r\nfunction compareFloatValues(reference_value, comparison_value, error_tolerance)\r\n{\r\n    // Check that reference and compare values are floats\r\n    const referenceIsFloat = checkDataTypes('float', { value: reference_value });\r\n    const comparisonIsFloat = checkDataTypes('float', { value: comparison_value });\r\n    const toleranceIsFloat = checkDataTypes('float', { value: error_tolerance });\r\n\r\n    if (toleranceIsFloat) {\r\n        if (referenceIsFloat && comparisonIsFloat) {\r\n            // Compare values to see if they are close to each other within bounds of error tolerance\r\n            const withinLowerBounds = comparison_value > (reference_value - error_tolerance);\r\n            const withinUpperBounds = comparison_value < (reference_value + error_tolerance);\r\n    \r\n            return withinLowerBounds && withinUpperBounds;\r\n        }\r\n        else if (!referenceIsFloat && comparisonIsFloat) {\r\n            // Reference value given was not a float value\r\n            console.error(typeErrorMessage('float', typeof reference_value, 'reference value'));\r\n    \r\n            return false;\r\n        }\r\n        else if (referenceIsFloat && !comparisonIsFloat) {\r\n            // Comparison value given was not a float value\r\n            console.error(typeErrorMessage('float', typeof comparison_value, 'comparison value'));\r\n    \r\n            return false;\r\n        }\r\n        else {\r\n            // Neither values given were a float value\r\n            console.error(typeErrorMessage('float', typeof reference_value, 'reference value'));\r\n            console.error(typeErrorMessage('float', typeof comparison_value, 'comparison value'));\r\n    \r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        // A non float error tolerance value was given\r\n        console.error(typeErrorMessage('float', typeof error_tolerance, 'error tolerance'));\r\n    \r\n        return false;\r\n    }\r\n}\r\n\r\nexport { checkDataTypes, checkParity, compareFloatValues }","import { typeErrorMessage, invalidErrorMessage } from './helpers';\r\nimport { checkDataTypes } from './validators';\r\n\r\nconst startingMonomerStatCount = {\r\n    mass:         0,    // Total number of masses given\r\n    percent:      0,    // Total number of percents given\r\n    determined:   0,    // Total number of comonomers with both mass and percent given\r\n    partial:      0     // Total number of comonomers with only either mass or percent given\r\n}\r\n\r\nexport default class FuncGroup {\r\n    constructor(percent_type, name, num, molar_eq, monomers, unknown = null) {\r\n        this.percent_type = percent_type;\r\n        this.name = name;\r\n        this.num = num;\r\n        this.molar_eq = molar_eq;\r\n        this.monomers = monomers;\r\n        this.isReference = false;\r\n        this.unknown = unknown;\r\n        this.monomerStatCount = { ...startingMonomerStatCount };\r\n    }\r\n\r\n    // Indicates whether this functional group is the reference (true) or complimentary group (false). Necessary for calculations\r\n    setIsReference = (reference_state = true) => {\r\n        this.isReference = reference_state;\r\n        return this.isReference;\r\n    }\r\n\r\n    // Indicates whether or not this functional group has an unknown monomer (no mass or percent given)\r\n    hasUnknown = () => this.unknown !== null;\r\n\r\n    #increment_monomer_stat_count = (monomer_stat) => {\r\n        this.monomerStatCount[monomer_stat]++;\r\n    }\r\n\r\n    determineMonomerStatCount = () => {\r\n        // Reset previous stat counts back to 0\r\n        this.monomerStatCount = { ...startingMonomerStatCount };\r\n\r\n        this.monomers.forEach((monomer) => {\r\n            const massGiven = monomer.massGiven();\r\n            const percentGiven = monomer.weightPercentGiven() || monomer.molePercentGiven();\r\n\r\n            if (massGiven) {\r\n                this.#increment_monomer_stat_count('mass');\r\n            }\r\n\r\n            if (percentGiven) {\r\n                this.#increment_monomer_stat_count('percent');\r\n            }\r\n                \r\n            if (massGiven && percentGiven) {\r\n                this.#increment_monomer_stat_count('determined');\r\n            }\r\n\r\n            // For groups with more than 1 comonomer, increment Partial Count if Mass is given and Percent is not given, and vice-versa\r\n            if (this.num > 1) {\r\n                const partial_info_given = (massGiven && !percentGiven) || (!massGiven && percentGiven);\r\n                \r\n                if (partial_info_given)\r\n                    this.#increment_monomer_stat_count('partial');\r\n            }\r\n        });\r\n\r\n        return this.monomerStatCount;\r\n    }\r\n\r\n    findRefMonomer = () => {\r\n        let i = 0;\r\n        let refMonomerFound = false;\r\n\r\n        // Loop through monomers array until the first monomer with mass and percent value known is found\r\n        while (i < this.monomers.length && !refMonomerFound)\r\n        {\r\n            const monomer = this.monomers[i];\r\n            refMonomerFound = monomer.massGiven() && (monomer.weightPercentGiven() || monomer.molePercentGiven());\r\n\r\n            // Go to the next monomer if no reference monomer was found\r\n            if (!refMonomerFound) i++;\r\n        }\r\n\r\n        if (refMonomerFound) {\r\n            const referenceMonomer = this.monomers[i];\r\n            return referenceMonomer;\r\n        }\r\n        else {\r\n            // No reference monomer could be found for this group\r\n            console.error(Error(`No reference monomer could be found for the ${this.name} functional group.`));\r\n            return false;\r\n        }\r\n    }\r\n\r\n    sumMonomerStat = (monomer_stat) => {\r\n        const sumValue = this.monomers.reduce((statSum, monomer) => {\r\n            const statValue = monomer[monomer_stat];\r\n            \r\n            if (statValue !== undefined) {\r\n                // Add this value to the stat sum\r\n                statSum += statValue;\r\n                return statSum;\r\n            }\r\n            else {\r\n                // Invalid monomer stat selected\r\n                console.error(Error(`Cannot sum ${monomer_stat}`));\r\n                return 0;\r\n            }\r\n        }, 0);\r\n\r\n        return sumValue;\r\n    }\r\n\r\n    // Get Functional Group property\r\n    getPercentType = () => this.percent_type;\r\n    getName = () => this.name;\r\n    getNum = () => this.num;\r\n    getMolarEQ = () => this.molar_eq;\r\n    getMonomers = (index = null) => {\r\n        // Check if index value was given\r\n        if (index === null) {\r\n            // Return monomers array if no index given\r\n            return this.monomers \r\n        } \r\n        // Return individual monomer at given index\r\n        else {\r\n            // Check that `index` is a valid index value (integer within bounds of monomers array)\r\n            const index_isValid = checkDataTypes('index', { value: index, index_end: this.num - 1 });\r\n            \r\n            if (index_isValid) {\r\n                // Return monomer at given index\r\n                return this.monomers[index];\r\n            }\r\n            else {\r\n                // Neither condition was acceptable\r\n                console.error(Error(`Index (${index}) must be a valid index value and within bounds of monomers array (0-${this.num - 1})`));\r\n            }\r\n        }\r\n    }\r\n    getIsReference = () => this.isReference;\r\n    getUnknown = () => this.monomers[this.unknown];\r\n    getMonomerStatCount = (stat_name = null) => {\r\n        switch (stat_name)\r\n        {\r\n            case null:\r\n                // Return the whole stat count object if stat name is `null`\r\n                return this.monomerStatCount;\r\n            case 'mass':\r\n            case 'percent':\r\n            case 'determined':\r\n            case 'partial':\r\n                // Return the selected stat count\r\n                return this.monomerStatCount[stat_name];\r\n            default:\r\n                // Invalid stat name selected\r\n                console.error(Error(`'${stat_name}' is not a valid monomerStatCount property selected`));\r\n                return 0;\r\n        }\r\n    }\r\n\r\n    #set_func_property(property_name, expected_type, value)\r\n    {\r\n        // Check that given value is expected data type\r\n        if (property_name === 'monomers')\r\n        {\r\n            const monomersIsArray = value instanceof Array;\r\n\r\n            if (!monomersIsArray)\r\n                throw typeErrorMessage(expected_type, typeof value, property_name);\r\n        }\r\n        else if (typeof value !== expected_type) \r\n            throw typeErrorMessage(expected_type, typeof value, property_name);\r\n        \r\n        switch (property_name)\r\n        {\r\n            case 'monomers':\r\n                const numMonomersGiven = value.length;\r\n\r\n                // Check that there is at least 1 monomer\r\n                if (numMonomersGiven <= 0) \r\n                    throw invalidErrorMessage('Functional groups must have at least 1 monomer', property_name);\r\n\r\n                // Check that the number of monomers given is equivalent to the num expected\r\n                if (numMonomersGiven !== this.num)\r\n                    throw invalidErrorMessage(`equivalent to the number of comonomers provided for ${this.name} functional group (${this.num})\\nInvalid value given: ${value}`, property_name);\r\n\r\n                break;\r\n            case 'unknown':\r\n                // Check that the value being set for unknown is a valid index value\r\n                const unknown_isIndex = checkDataTypes('index', { value, index_end: this.num - 1 });\r\n                if (!unknown_isIndex)\r\n                    throw invalidErrorMessage('A functional group unknown must be an index value of type integer', value);\r\n                \r\n                break;\r\n            default:\r\n                throw Error(`Invalid functional group property. Cannot update (${property_name})`);\r\n        }\r\n\r\n        // Set property to given value\r\n        this[property_name] = value;\r\n    }\r\n    \r\n    // Set Monomer properties, checking that given value is valid\r\n    setMonomers = (monomers) => this.#set_func_property('monomers', 'Array', monomers);\r\n    setUnknown = (unknown_monomer_index) => this.#set_func_property('unknown', 'number', unknown_monomer_index);\r\n\r\n    // Clears Monomer values given, so that new monomers can be easily entered\r\n    clearMonomers = () => {\r\n        // Manually set `monomers` array to empty list\r\n        this.monomers = [];\r\n        \r\n        // Return the empty monomer array\r\n        return this.monomers;\r\n    }\r\n}","import React from 'react';\r\nimport { useFuncGroups, useFuncDispatch } from '../../contexts/FuncContext';\r\nimport { UPDATE_FUNC, INITIALIZE_MONOMERS } from '../../contexts/actions';\r\nimport { FUNC_FORM, MONOMER_FORM } from '../../contexts/page_names';\r\n// Import default starting values for Functional Group and Form fields\r\nimport { DEFAULT_FUNC_GROUP_DATA, REQUIRED_FUNC_FIELDS } from './defaults/func_group_data';\r\n// Import default generation function for Monomer Form fields\r\nimport { GENERATE_MONOMER_FORM_FIELDS } from './defaults/monomer_data';\r\n\r\n// Import FuncGroup Class for defining input data\r\nimport FuncGroup from '../../utils/FuncGroup';\r\n// Import validator functions and error message generation\r\nimport { checkDataTypes, checkParity } from '../../utils/validators';\r\nimport { invalidErrorMessage } from '../../utils/helpers';\r\n\r\nexport default function FuncGroupForm()\r\n{\r\n    const { formData, funcGroups } = useFuncGroups();\r\n    const { setFormData, setFuncGroup, setPage } = useFuncDispatch();\r\n\r\n    const handleFormChange = (event) => {\r\n        const { name, value } = event.target;\r\n\r\n        // Update form field to new value\r\n        setFormData({ formType: FUNC_FORM, formField: name, value });\r\n    }\r\n\r\n    // Functions to increment/decrement monomer number fields\r\n    const subtractMonomerNum = (func_letter) => {\r\n        const num_field_name = `func${func_letter}_num`;\r\n        let current_value = parseInt(formData.funcGroupsForm[num_field_name]);\r\n        \r\n        if (current_value > 1 && current_value % 1 === 0) \r\n        {\r\n            // The current value is a sufficiently large whole number, decrement it\r\n            setFormData({ formType: FUNC_FORM, formField: num_field_name, value: current_value - 1 });\r\n        } \r\n        else if (current_value > 2 && current_value % 1 !== 0) \r\n        {\r\n            // The current value is a sufficiently large decimal number, floor and then decrement\r\n            current_value = Math.floor(current_value) - 1;\r\n            setFormData({ formType: FUNC_FORM, formField: num_field_name, value: current_value });\r\n        } \r\n        else if (current_value > 1 && current_value < 2 && current_value % 1 !== 0) \r\n        {\r\n            // The current value is a decimal number between 1 and 2, set it to 1\r\n            setFormData({ formType: FUNC_FORM, formField: num_field_name, value: 1 });\r\n        } \r\n        else \r\n        {\r\n            // Set unexpected value to 1\r\n            setFormData({ formType: FUNC_FORM, formField: num_field_name, value: 1 });\r\n        }\r\n    }\r\n\r\n    const addMonomerNum = (func_letter) => {\r\n        const num_field_name = `func${func_letter}_num`;\r\n        let current_value = parseInt(formData.funcGroupsForm[num_field_name]);\r\n        \r\n        if (current_value % 1 === 0) \r\n        {\r\n            // The current value is a whole number, increment it\r\n            setFormData({ formType: FUNC_FORM, formField: num_field_name, value: current_value + 1 });\r\n        } \r\n        else if (current_value % 1 > 0) \r\n        {\r\n            // The current value is a decimal number, floor and then increment it\r\n            current_value = Math.floor(current_value) + 1;\r\n            setFormData({ formType: FUNC_FORM, formField: num_field_name, value: current_value });\r\n        } \r\n        else \r\n        {\r\n            // Set unexpected value to 1\r\n            setFormData({ formType: FUNC_FORM, formField: num_field_name, value: 1 });\r\n        }\r\n    }\r\n\r\n    const handleFormSubmission = () => {\r\n        // Get Func Groups Form\r\n        const { funcGroupsForm } = formData;\r\n\r\n        // Determine percent type by selecting Weight Percent Radio Button and see if it is checked\r\n        const wt_percent_checked = document.getElementById(\"wpercent\").checked;\r\n\r\n        // Since there are only two options, if weight percent is not checked, then mole percent is, and vice-versa\r\n        const PERCENT_TYPE = wt_percent_checked \r\n            ? 'weight' \r\n            : 'mole';\r\n\r\n        // Check that functional group names are unique (duplicate names are not allowed)\r\n        const { funcA_name, funcB_name } = funcGroupsForm;\r\n        const funcNamesIdentical = checkParity(funcA_name.toLowerCase(), funcB_name.toLowerCase());\r\n\r\n        if (funcNamesIdentical) {\r\n            // Names cannot be identical, exit out of function\r\n            console.error(invalidErrorMessage('unique', 'Functional group names'));\r\n            return;\r\n        }\r\n\r\n        // Check whether an excess functional group has been selected, and determine the molar eq\r\n        const xs_A_selected = funcGroupsForm.xsGroup === 'A';\r\n        const xs_B_selected = funcGroupsForm.xsGroup === 'B';\r\n\r\n        const molar_eq_is_checked = funcGroupsForm.isExcessEQ;\r\n        const molar_eq_selected = xs_A_selected || xs_B_selected;\r\n\r\n        if (molar_eq_is_checked && !molar_eq_selected) {\r\n            // Excess functional group was selected, but no group selected, exit out of function\r\n            console.error(invalidErrorMessage('selected if excess molar eq is selected', 'Excess functional group'));\r\n            return;\r\n        }\r\n\r\n        // Track that all given inputs are acceptable\r\n        let inputsAcceptable = true;\r\n\r\n        const parsedFuncGroups = DEFAULT_FUNC_GROUP_DATA.map(({ letter }) => {\r\n            // Get functional group form values, accessed with key value, identified by `letter`\r\n            const name = funcGroupsForm[`func${letter}_name`];\r\n            const num = parseInt(funcGroupsForm[`func${letter}_num`]);\r\n            // Depending on whether excess molar eq was selected, determine molar eq for this func group\r\n            const determineMolarEq = () => {\r\n                if (xs_A_selected && letter === 'A') \r\n                    return parseFloat(funcGroupsForm.func_xs);\r\n                else if (xs_B_selected && letter === 'B') \r\n                    return parseFloat(funcGroupsForm.func_xs);\r\n                else\r\n                    return 1.0;\r\n            }\r\n\r\n            // Determine molar eq for this functional group; if not selected, default to `1.0`\r\n            const molar_eq = molar_eq_is_checked ? determineMolarEq() : 1.0;\r\n\r\n            // Check that input values are acceptable and the correct datatype\r\n            const nameAcceptable = checkDataTypes('string', { value: name });\r\n            const numAcceptable = checkDataTypes('int', { value: num });\r\n            const molar_eqAcceptable = checkDataTypes('float', { value: molar_eq, isMonomer: false });\r\n            \r\n            if (nameAcceptable && numAcceptable && molar_eqAcceptable)\r\n            {\r\n                // Create Functional Group object with the FuncGroup class and validated values\r\n                return {\r\n                    data: new FuncGroup\r\n                    (\r\n                        PERCENT_TYPE,\r\n                        name,\r\n                        num,\r\n                        molar_eq,\r\n                        []          // Initialize monomer list to empty array\r\n                    ),\r\n                    isOK: inputsAcceptable\r\n                };\r\n            } else\r\n            {\r\n                const ERROR_MESSAGE = `One or multiple of the values given for Functional Group ${letter} is missing or invalid.`;\r\n                console.error(ERROR_MESSAGE);\r\n                inputsAcceptable = false;\r\n                return { message: ERROR_MESSAGE, isOK: inputsAcceptable };\r\n            }\r\n            \r\n        });\r\n\r\n        console.log('Parsed funcGroups: ', parsedFuncGroups);\r\n        console.log('Reducer State: ', funcGroups);\r\n\r\n        // Check that both functional groups are valid by only returning acceptable values\r\n        const validFuncGroups = parsedFuncGroups.reduce((validatedFuncGroups, funcGroup) => {\r\n            if (funcGroup.isOK)\r\n                validatedFuncGroups.push(funcGroup.data);\r\n\r\n            return validatedFuncGroups;\r\n        }, []);\r\n        \r\n        // Check that both functional groups are valid\r\n        if (validFuncGroups.length === 2)\r\n        {\r\n            // Update the Functional Group Context with the validated func group data\r\n            setFuncGroup({ type: UPDATE_FUNC, funcGroups: validFuncGroups });\r\n            \r\n            // Initialize starting monomer form fields based on functional group information\r\n            setFormData({ formType: INITIALIZE_MONOMERS, formField: null, value: GENERATE_MONOMER_FORM_FIELDS(validFuncGroups) });\r\n        }\r\n        else\r\n            console.error(Error('One of the functional groups was given invalid input. Please try again.'));\r\n        \r\n    }\r\n\r\n    React.useEffect(() => {\r\n        const { funcGroupsForm, monomersForm } = formData;\r\n        \r\n        const funcContextUpdated = funcGroups !== undefined && funcGroups.length > 0;\r\n        const monomerFieldsGenerated = monomersForm !== undefined;\r\n\r\n        // Check that all required fields are not blank, ignore any that are not required\r\n        let numReqFieldsNotFilled = 0;\r\n\r\n        for (let field in funcGroupsForm) \r\n        {\r\n            const fieldIsRequired = REQUIRED_FUNC_FIELDS[field];\r\n            const fieldValue = funcGroupsForm[field];\r\n            \r\n            if (fieldIsRequired && fieldValue === '')\r\n                numReqFieldsNotFilled++;\r\n        }\r\n        \r\n        if (funcContextUpdated && (numReqFieldsNotFilled === 0) && monomerFieldsGenerated) {\r\n            setPage({ page: MONOMER_FORM });\r\n        } \r\n    }, [formData, funcGroups, setPage]);\r\n    \r\n    return(\r\n        <div className=\"form_container\">\r\n            <form id=\"initial_data_entry\">\r\n                <section className=\"percent_type\">\r\n                    <label>\r\n                        Weight %\r\n                        <input type=\"radio\" name=\"proportion\" value=\"wpercent\" id=\"wpercent\" className=\"input_field\" defaultChecked={true} />\r\n                    </label>\r\n                    <label>\r\n                        Mole %\r\n                        <input type=\"radio\" name=\"proportion\" value=\"mpercent\" id=\"mpercent\" className=\"input_field\" />\r\n                    </label>\r\n                </section>\r\n                <section className=\"ag_box\">\r\n                    {DEFAULT_FUNC_GROUP_DATA.map(({ letter, name_placeholder, num_placeholder }) =>\r\n                        <div key={`func_group_${letter}`}>\r\n                            <h1>Functional Group {letter}</h1>\r\n                            <div className=\"input_block\">\r\n                                <label>\r\n                                    Substituent Name\r\n                                    <input \r\n                                        type=\"text\" \r\n                                        name={`func${letter}_name`} \r\n                                        value={formData.funcGroupsForm[`func${letter}_name`]} \r\n                                        onChange={handleFormChange}\r\n                                        placeholder={`e.g. '${name_placeholder}'`} \r\n                                        id={`func${letter}_name`} \r\n                                        className=\"input_field string\" \r\n                                    />\r\n                                </label>\r\n                            </div>\r\n                            <br />\r\n                            <div className=\"input_block\">\r\n                                <label>\r\n                                    Number of Comonomers\r\n                                    <input \r\n                                        type=\"text\" \r\n                                        name={`func${letter}_num`} \r\n                                        value={formData.funcGroupsForm[`func${letter}_num`]} \r\n                                        onChange={handleFormChange}\r\n                                        placeholder={`e.g. '${num_placeholder}'`} \r\n                                        id={`func${letter}_num`} \r\n                                        className=\"input_field int\" \r\n                                    />\r\n                                </label>\r\n                                <button \r\n                                    type=\"button\" name=\"minus\" \r\n                                    onClick={() => subtractMonomerNum(letter)} \r\n                                    className=\"square_button plus_minus\" tabIndex=\"-1\"\r\n                                >\r\n                                    <div>-</div>\r\n                                </button>\r\n                                <button \r\n                                    type=\"button\" name=\"plus\" \r\n                                    onClick={() => addMonomerNum(letter)} \r\n                                    className=\"square_button plus_minus\" tabIndex=\"-1\"\r\n                                >\r\n                                    <div>+</div>\r\n                                </button>\r\n                            </div>\r\n                            <br />\r\n                        </div>\r\n                    )}\r\n                </section>\r\n                <br />\r\n                <section className=\"optional\">\r\n                    <div className=\"input_block\">\r\n                        <label>\r\n                            Is either group in excess?\r\n                            <input \r\n                                type=\"checkbox\" name=\"molar_eq_check\" \r\n                                id=\"molar_eq_check\"\r\n                                onClick={({ target }) => setFormData({ formType: FUNC_FORM, formField: 'isExcessEQ', value: target.checked })}\r\n                                className=\"check_box\" tabIndex=\"-1\"\r\n                            ></input>\r\n                        </label>\r\n                    </div>\r\n                    <br />\r\n                    {formData.funcGroupsForm.isExcessEQ ?\r\n                    <div id=\"molar_eq_container\">\r\n                        <div className=\"input_block\">\r\n                            {DEFAULT_FUNC_GROUP_DATA.map(({ letter }) =>\r\n                                <div className={formData.funcGroupsForm.xsGroup === letter ? \"selected\" : \"unselected\"} id={`func${letter}_eq`} key={`func${letter}_eq`} >\r\n                                    <button \r\n                                        type=\"button\" \r\n                                        name={`xs_${letter}`} \r\n                                        onClick={() => setFormData({ formType: FUNC_FORM, formField: 'xsGroup', value: formData.funcGroupsForm.xsGroup === letter ? '' : letter })} \r\n                                        className=\"square_button inactive_button\"\r\n                                    >\r\n                                        {letter}\r\n                                    </button>\r\n                                </div>\r\n                            )}\r\n                            <label>\r\n                                Molar Equivalents\r\n                                <input \r\n                                    type=\"text\" \r\n                                    name=\"func_xs\" \r\n                                    value={formData.funcGroupsForm.func_xs} \r\n                                    onChange={handleFormChange}\r\n                                    placeholder=\"e.g. '1.1'\" \r\n                                    id=\"func_xs\" \r\n                                    className=\"input_field float\" />\r\n                            </label>\r\n                        </div>\r\n                    </div>\r\n                    : ''}\r\n                </section>\r\n                \r\n                <div className=\"submit_container\">\r\n                    <button type=\"button\" onClick={() => handleFormSubmission()} id=\"initial_submit\" className=\"submit_button\">Next</button>\r\n                </div>\r\n            </form>\r\n        </div>\r\n    );\r\n}","import { typeErrorMessage, invalidErrorMessage } from './helpers';\r\nimport { SIG_FIG, INVALID_PLACEHOLDER } from './standards';\r\n\r\n// All properties of monomer should be a number\r\nconst EXPECTED_TYPE = typeof Number();\r\n\r\nexport default class Monomer {\r\n    constructor(mass, wpercent, mpercent, molar_mass, moles) {\r\n        this.mass = mass;\r\n        this.wpercent = wpercent;\r\n        this.mpercent = mpercent;\r\n        this.molar_mass = molar_mass;\r\n        this.moles = moles;\r\n    }\r\n\r\n    // Get Monomer property\r\n    getMass = () => this.mass;\r\n    getWeightPercent = () => this.wpercent;\r\n    getMolePercent = () => this.mpercent;\r\n    getMolarMass = () => this.molar_mass;\r\n    getMoles = () => this.moles;\r\n\r\n    #set_monomer_property(property_name, expected_type, value)\r\n    {\r\n        try {\r\n            // Check that given value is expected data type\r\n            if (typeof value !== expected_type) \r\n                throw typeErrorMessage(expected_type, typeof value, property_name);\r\n        \r\n            // Check that number value is a natural number (greater than or equal to 0)\r\n            if (value < 0) \r\n                throw invalidErrorMessage('greater than 0', property_name);\r\n\r\n            // Set property to given value\r\n            this[property_name] = value;\r\n\r\n            // Return the updated property value\r\n            return this[property_name];\r\n        }\r\n        catch (error) {\r\n            console.error(error);\r\n        }\r\n    }\r\n    \r\n    // Set Monomer properties, checking that given value is valid\r\n    setMass = (mass_value) => this.#set_monomer_property('mass', EXPECTED_TYPE, mass_value);\r\n    setWeightPercent = (wpercent_value) => this.#set_monomer_property('wpercent', EXPECTED_TYPE, wpercent_value);\r\n    setMolePercent = (mpercent_value) => this.#set_monomer_property('mpercent', EXPECTED_TYPE, mpercent_value);\r\n    setMolarMass = (molar_mass_value) => this.#set_monomer_property('molar_mass', EXPECTED_TYPE, molar_mass_value);\r\n    setMoles = (moles_value) => this.#set_monomer_property('moles', EXPECTED_TYPE, moles_value);\r\n\r\n    // Indicates if mass, weight percent, or moles percent have been given\r\n    massGiven = () => this.mass > 0;\r\n    weightPercentGiven = () => this.wpercent > 0;\r\n    molePercentGiven = () => this.mpercent > 0;\r\n\r\n    // Display Monomer properties\r\n    display = (monomer_property) => {\r\n        const property_value = this[monomer_property];\r\n\r\n        switch (monomer_property)\r\n        {\r\n            case 'mass':\r\n            case 'wpercent':\r\n            case 'mpercent':\r\n            case 'molar_mass':\r\n            case 'moles':\r\n                let format_options = {};\r\n\r\n                if (property_value >= 1000) {\r\n                    format_options = { notation: 'scientific', maximumSignificantDigits: SIG_FIG };\r\n                    const formatted_molar_mass = Intl.NumberFormat('en-US', format_options).format(property_value);\r\n                    return improveScientificNotation(formatted_molar_mass);\r\n                }\r\n                else if (property_value < 1000 && property_value >= 100) \r\n                    format_options = { maximumSignificantDigits: SIG_FIG + 2 };\r\n                else if (property_value < 100 && property_value >= 10) \r\n                    format_options = { maximumSignificantDigits: SIG_FIG + 1 };\r\n                else if (property_value < 10 && property_value >= 1) \r\n                    format_options = { maximumSignificantDigits: SIG_FIG };\r\n                else if (property_value < 1) {\r\n                    format_options = { notation: 'scientific', maximumSignificantDigits: SIG_FIG };\r\n                    const formatted_molar_mass = Intl.NumberFormat('en-US', format_options).format(property_value);\r\n                    return improveScientificNotation(formatted_molar_mass);\r\n                }\r\n\r\n                const formatted_molar_mass = Intl.NumberFormat('en-US', format_options).format(property_value);\r\n                return formatted_molar_mass;\r\n                \r\n            default:\r\n                // Invalid monomer property selected\r\n                const invalid_monomer_property = invalidErrorMessage('a valid property.', 'Selected monomer property');\r\n                console.error(invalid_monomer_property);\r\n                return INVALID_PLACEHOLDER;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @param {string} scientific_value - Value in the format '1.11E-3' for 0.00111\r\n * @returns \r\n */\r\nfunction improveScientificNotation(scientific_value)\r\n{\r\n    // Get notation components\r\n    const base_ten = `${String.fromCodePoint(215)} 10`;\r\n    const [ coefficient, exponent ] = scientific_value.split('E'); \r\n\r\n    // Format the moles to display in markup\r\n    return <span>{`${coefficient} ${base_ten}`}<sup>{exponent}</sup></span>;\r\n}","\r\nexport function startDataSorting(funcGroups) {\r\n    const [ funcA, funcB ] = funcGroups;\r\n\r\n    // Get the updated functional groups with monomer stat counts for both A and B\r\n    const funcA_statCount = funcA.determineMonomerStatCount();\r\n    const funcB_statCount = funcB.determineMonomerStatCount();\r\n\r\n    const { mass: funcA_massCount, percent: funcA_percentCount } = funcA_statCount;\r\n    const { mass: funcB_massCount, percent: funcB_percentCount } = funcB_statCount;\r\n\r\n    // Check that functional groups have at least 1 mass or more, and that the total number of knowns for percent and mass are greater than or equal to the number of comonomers\r\n    const funcA_canBeReference = funcA_massCount >= 1 && ((funcA_massCount + funcA_percentCount) >= funcA.getNum())\r\n    const funcB_canBeReference = funcB_massCount >= 1 && ((funcB_massCount + funcB_percentCount) >= funcB.getNum())\r\n\r\n    // Determine which of the functional groups should be the reference group\r\n    if (funcA_canBeReference && !funcB_canBeReference) {\r\n        // Only Functional Group A is a suitable reference group\r\n        funcA.setIsReference();\r\n    }\r\n    else if (!funcA_canBeReference && funcB_canBeReference) {\r\n        // Only Functional Group B is a suitable reference group\r\n        funcB.setIsReference();\r\n    }\r\n    else if (funcA_canBeReference && funcB_canBeReference) {\r\n        // Both functional groups are suitable reference groups. Determine functional group with greater proportion of knowns to be reference group\r\n        const funcA_xsKnowns = (funcA_massCount + funcA_percentCount) - funcA.getNum();\r\n        const funcB_xsKnowns = (funcB_massCount + funcB_percentCount) - funcB.getNum();\r\n\r\n        // A greater mass proportion signifies more mass values given, which indicates a more suitable reference group\r\n        const funcA_massProportion = funcA_massCount - funcA.getNum();\r\n        const funcB_massProportion = funcB_massCount - funcB.getNum();\r\n\r\n        if (funcA_xsKnowns > funcB_xsKnowns || funcA_massProportion > funcB_massProportion) {\r\n            // Functional group A has either more information given or more masses given, so it is the more suitable reference group\r\n            funcA.setIsReference();\r\n        }\r\n        else if (funcB_xsKnowns > funcA_xsKnowns  || funcB_massProportion > funcA_massProportion) {\r\n            // Functional group B has either more information given or more masses given, so it is the more suitable reference group\r\n            funcB.setIsReference();\r\n        }\r\n        else {\r\n            // The proportions for functional groups A & B are equivalent, so the reference group defaults to A\r\n            funcA.setIsReference();\r\n        }\r\n    }\r\n    else {\r\n        // Neither functional groups are a suitable reference group; return false to indicate failed data sorting\r\n        return false;\r\n    }\r\n\r\n    // Find calculation routes for each functional group\r\n    const funcA_route = findRoute(funcA);\r\n    const funcB_route = findRoute(funcB);\r\n\r\n    // Check that calculation route was found for both functional groups\r\n    if (!funcA_route && !funcB_route) {\r\n        // Neither functional group found a valid calculation route\r\n        console.error(Error(`Neither functional group ${funcA.getName()} or ${funcB.getName()} have a valid calculation route.`));\r\n        return false;\r\n    }      \r\n    else if (!funcA_route && funcB_route) {\r\n        // No valid calculation route for functional group B\r\n        console.error(Error(`No valid calculation route for functional group for ${funcB.getName()}.`));\r\n        return false;\r\n    } \r\n    else if (funcA_route && !funcB_route) {\r\n        // No valid calculation route for functional group A\r\n        console.error(Error(`No valid calculation route for functional group for ${funcA.getName()}.`));\r\n        return false;\r\n    }\r\n    \r\n    return [funcA_route, funcB_route];\r\n}\r\n\r\nfunction findRoute(funcGroup) {\r\n\r\n    /*  Route Finder:\r\n        (1) - Determine what are known values for monomers by boolean expressions based on stat counts\r\n        (2) - Select an appropiate calculation route for reference and complimentary groups\r\n    */\r\n\r\n    const { percent_type, num: funcNum, isReference: funcIsReference, unknown } = funcGroup;\r\n\r\n    const { \r\n        mass: massCount, \r\n        percent: percentCount, \r\n        determined: determinedCount, \r\n        partial: partialCount } = funcGroup.monomerStatCount;\r\n\r\n    // (1)\r\n    const mass_present = massCount >= 1;\r\n    const percent_present = percentCount >= 1;\r\n    const determined_present = determinedCount >= 1;\r\n\r\n    const all_mass = massCount === funcNum;\r\n    const all_percent = percentCount === funcNum;\r\n    const almost_all_mass = massCount === funcNum - 1;\r\n    const almost_all_percent = percentCount === funcNum - 1;\r\n\r\n    // The Tetris Route requires that there is a determined comonomer, 1 unknown comnomer, and that all remaining comonomers are partially known\r\n    let tetris_possible = determined_present && unknown !== null && (partialCount === funcNum - 2);\r\n\r\n    // Scenarios which have special conditions depending on whether the functional group is reference or complimentary\r\n    let excess_info, zpr_possible;\r\n\r\n    // Determine if excess information given and/or zipper route is possible\r\n    if (funcIsReference) {\r\n        // Reference Group\r\n        const ref_knowns = massCount + percentCount;\r\n\r\n        // Only n (funcNum) information needs to be given for calculations to be possible, anything more is unnecessary and must be accounted for user error\r\n        excess_info = ref_knowns > funcNum;\r\n\r\n        // The Reference Zipper Route requires that all comonomers be partially known with at least one mass given\r\n        zpr_possible = partialCount === funcNum && mass_present;\r\n    }\r\n    else {\r\n        // Complimentary Group\r\n        const comp_knowns = massCount + percentCount;\r\n\r\n        // Determines if more information than necessary was given\r\n        excess_info = funcNum === 1 \r\n            ? mass_present                  // Excess info if there is only one monomer with mass given\r\n            : comp_knowns > funcNum - 1;    // Excess info if knowns exceeds n - 1\r\n\r\n        // The Complimentary Zipper Route requires that nearly all comonomers be partially known with at least one mass given, and that there is an unknown comonomer present\r\n        zpr_possible = partialCount === funcNum - 1 && mass_present && unknown !== null;\r\n    }\r\n    \r\n    // (2)\r\n    // REFERENCE GROUP\r\n    if (funcIsReference) {\r\n\r\n       // All Mass Route - All comonomer masses given and no percent values given\r\n        if (all_mass && (funcNum === 1 || !percent_present)) {\r\n            console.log(\"Your calculation route for reference group is: All Mass\");\r\n            return 'ALLMASSROUTE';\r\n        }\r\n\r\n       // Zipper Route = Every comonomer either has mass as a known and percent as an unknown, and vice-versa\r\n        else if (zpr_possible) {\r\n            switch (percent_type) {\r\n                case 'weight':\r\n                    console.log(\"Your calculation route for reference group is: wt% Zipper\");\r\n                    return 'WTP_ZIPPERROUTE';\r\n                case 'mole':\r\n                    console.log(\"Your calculation route for reference group is: ml% Zipper\");\r\n                    return 'MLP_ZIPPERROUTE';\r\n                default:\r\n                    return false;\r\n            }\r\n            \r\n        }\r\n    \r\n       // Excess Info - The user has given more information than necessary. User error is a concern for this route\r\n       // Tetris Route - One reference monomer, one unknown, and all other comonomer(s) partially known\r\n        else if (excess_info || tetris_possible) {\r\n            switch (percent_type) {\r\n                case 'weight':\r\n                    if (tetris_possible) {\r\n                        console.log(\"Your calculation route for reference group is: wt% Tetris via xs info\");\r\n                    } \r\n                    else {\r\n                        console.log(\"Your calculation route for reference group is: Excess wt%\");\r\n                    }\r\n                    \r\n                    return 'XS_WTPROUTE';\r\n                case 'mole':\r\n                    if (tetris_possible) {\r\n                        console.log(\"Your calculation route for reference group is: ml% Tetris via xs info\");\r\n                    } \r\n                    else {\r\n                        console.log(\"Your calculation route for reference group is: Excess ml%\");\r\n                    }\r\n\r\n                    return 'XS_MLPROUTE';\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n        \r\n        // No calculation route was able to be found for the reference group with the information given\r\n        else {\r\n            console.log(\"No calculation route could be found for your reference group.\\n\\tIt may be missing key information (mass) and/or not have enough information:\\n\\tNUMBER OF KNOWNS SHOULD BE GREATER THAN OR EQUAL TO NUMBER OF MONOMERS\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // COMPLIMENTARY GROUP\r\n    else {\r\n        // All Percent Route - All comonomer percents given and no mass values given\r\n        if ((all_percent || almost_all_percent) && !mass_present) {\r\n            console.log(\"Your calculation route for complimentary group is: All Percent\");\r\n            return 'ALLPERCENTROUTE';\r\n        }\r\n\r\n        // Given Mass Route - Almost all masses given with no percents given\r\n        else if (almost_all_mass && !percent_present) {\r\n            console.log(\"Your calculation route for complimentary group is: Given Mass\");\r\n            return 'GIVENMASSROUTE';\r\n        }\r\n\r\n       // Zipper Route - One unknown and almost every comonomer either has mass as a known and percent as an unknown, and vice-versa\r\n        else if (zpr_possible) {\r\n            switch (percent_type) {\r\n                case 'mole':\r\n                    console.log(\"Your calculation route for complimentary group is: Mol Percent Zipper\");\r\n                    return 'MLP_ZIPPERROUTE';\r\n                case 'weight':\r\n                    console.log(\"Your calculation route for complimentary group is: Wt Percent Zipper\");\r\n                    return 'WTP_ZIPPERROUTE';\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        // Excess Info - The user has given more information than necessary. User error is a concern for this route\r\n        else if (excess_info) {\r\n            switch (percent_type) {\r\n                case 'mole':\r\n                    console.log(\"Your calculation route for complimentary group is: Mol Percent Excess Info\");\r\n                    return 'MLP_XS_INFOROUTE';\r\n                case 'weight':\r\n                    console.log(\"Your calculation route for complimentary group is: Wt Percent Excess Info\");\r\n                    return 'WTP_XS_INFOROUTE';\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        // No calculation route was able to be found for the complimentary group with the information given\r\n        else {\r\n            console.log(\"No calculation route could be found for your complimentary group.\\n\\tIt may not have enough information:\\n\\tNUMBER OF KNOWNS SHOULD BE GREATER THAN OR EQUAL TO (NUMBER OF MONOMERS - 1)\");\r\n            return false;\r\n        }\r\n    }\r\n}","import { compareFloatValues } from \"./validators\";\r\nimport { ERROR_TOLERANCE } from \"./standards\";\r\n\r\nexport function doReferenceCalculations(refGroup, calculation_route)\r\n{\r\n    switch (calculation_route)\r\n    {\r\n        case 'ALLMASSROUTE':        return      ref_allMass(refGroup);    \r\n        case 'WTP_ZIPPERROUTE':     return      ref_wtpZipper(refGroup);  \r\n        case 'MLP_ZIPPERROUTE':     return      ref_mlpZipper(refGroup);  \r\n        case 'XS_WTPROUTE':         return      ref_xsWeight(refGroup);   \r\n        case 'XS_MLPROUTE':         return      ref_xsMole(refGroup);   \r\n        default:                    return      false;  \r\n    }\r\n}\r\n\r\nexport function doComplimentaryCalculations(refGroup, compGroup, calculation_route)\r\n{\r\n    switch (calculation_route)\r\n    {\r\n        case 'ALLPERCENTROUTE':     return      comp_allPercent(refGroup, compGroup);\r\n        case 'GIVENMASSROUTE':      return      comp_givenMass(refGroup, compGroup); \r\n        case 'MLP_ZIPPERROUTE':     return      comp_mlpZipper(refGroup, compGroup); \r\n        case 'WTP_ZIPPERROUTE':     return      comp_wtpZipper(refGroup, compGroup); \r\n        case 'MLP_XS_INFOROUTE':    return      comp_mlpXS(refGroup, compGroup);     \r\n        case 'WTP_XS_INFOROUTE':    return      comp_wtpXS(refGroup, compGroup);  \r\n        default:                    return      false;  \r\n    }\r\n}\r\n\r\n// Reference calculations\r\nfunction ref_allMass(refGroup)\r\n{\r\n    const mass_sum = refGroup.sumMonomerStat('mass');\r\n         \r\n    refGroup.getMonomers().forEach((monomer) => {\r\n        // Calculating Wt% from mass and total mass\r\n        const wpercent = (monomer.getMass() / mass_sum) * 100.0;\r\n        monomer.setWeightPercent(wpercent);\r\n\r\n        // Calculating moles from mass and molar mass\r\n        const moles = monomer.getMass() / monomer.getMolarMass();\r\n        monomer.setMoles(moles);\r\n    });\r\n    \r\n    const mol_sum = refGroup.sumMonomerStat('moles');\r\n    \r\n    refGroup.getMonomers().forEach((monomer) => {\r\n        // Calculating Ml% from moles and total moles\r\n        const mpercent = (monomer.getMoles() / mol_sum) * 100.0;\r\n        monomer.setMolePercent(mpercent);\r\n    });\r\n        \r\n    // Calculations were successful for the All Mass Route\r\n    return true;\r\n}\r\n\r\nfunction ref_wtpZipper(refGroup)\r\n{\r\n    // These represent their respective partial sums where they each make up a fraction of the functional group with the other making up the difference\r\n    const mass_sum = refGroup.sumMonomerStat('mass');\r\n    const percent_sum = refGroup.sumMonomerStat('wpercent');\r\n    \r\n    // Total mass percent is the percentage that masses take up that is unaccounted for (e.g. total percents are 60%, therefore the knowns masses account for 40%)\r\n    const total_mass_percent = 100.0 - percent_sum;\r\n\r\n    // This gives the ratio between mass and percent (e.g. 4 g for 40% means that 20% would be 2 g or that 55% would be 5.5 g)\r\n    const g_per_percent = mass_sum / total_mass_percent;\r\n    \r\n    // Loop through given values for comonomers and use predefined ratios of mass and percent to find their respective unknowns\r\n    refGroup.getMonomers().forEach((monomer) => {\r\n        // Mass is known, so calculate the value for weight percent\r\n        if (!monomer.weightPercentGiven() && monomer.massGiven()) {\r\n            const wpercent = monomer.getMass() / g_per_percent;\r\n            monomer.setWeightPercent(wpercent);\r\n        }\r\n        // Weight percent is known, so calculate the value for mass\r\n        else if (monomer.weightPercentGiven() && !monomer.massGiven()) {\r\n            const mass = monomer.getWeightPercent() * g_per_percent;\r\n            monomer.setMass(mass);\r\n        }\r\n        \r\n        // Mass should be known, so calculate moles using molar mass\r\n        const moles = monomer.getMass() / monomer.getMolarMass();\r\n        monomer.setMoles(moles);\r\n    });\r\n    \r\n    const mol_sum = refGroup.sumMonomerStat('moles');\r\n\r\n    refGroup.getMonomers().forEach((monomer) => {\r\n        // Calculating Ml% from moles and total moles\r\n        const mpercent = (monomer.getMoles() / mol_sum) * 100.0;\r\n        monomer.setMolePercent(mpercent);\r\n    });\r\n    \r\n    // Calculations were successful for the Weight Percent Zipper Route\r\n    return true;\r\n}\r\n\r\nfunction ref_mlpZipper(refGroup)\r\n{\r\n    // Cycle through functional group to find comonomers with mass, and calculate their moles if so\r\n    refGroup.getMonomers().forEach((monomer) => {\r\n        if (monomer.massGiven()) {\r\n            const moles = monomer.getMass() / monomer.getMolarMass();\r\n            monomer.setMoles(moles);\r\n        }\r\n    });\r\n\r\n    // These represent their respective partial sums where they each make up a fraction of the functional group with the other making up the difference\r\n    const mol_sum = refGroup.sumMonomerStat('moles');\r\n    const percent_sum = refGroup.sumMonomerStat('mpercent');\r\n\r\n    // Total mole percent is the percentage that moles take up that is unaccounted for (e.g. total percents are 60%, therefore the knowns moles account for 40%)\r\n    const total_mol_percent = 100.0 - percent_sum;\r\n\r\n    // This gives the ratio between moles and percent (e.g. 0.04 mol for 40% means that 20% would be 0.02 mol or that 55% would be 0.055 mol)\r\n    const mol_per_percent = mol_sum / total_mol_percent;\r\n\r\n    refGroup.getMonomers().forEach((monomer) => {\r\n        // Moles are known (mass is given), so calculate the value for mole percent\r\n        if (!monomer.molePercentGiven() && monomer.massGiven()) {\r\n            const mpercent = monomer.getMoles() / mol_per_percent;\r\n            monomer.setMolePercent(mpercent);\r\n        }\r\n        // Mole percent is known, so calculate the value for moles then mass\r\n        else if (monomer.molePercentGiven() && !monomer.massGiven()) {\r\n            const moles = monomer.getMolePercent() * mol_per_percent;\r\n            const mass = moles * monomer.getMolarMass();\r\n            monomer.setMoles(moles);\r\n            monomer.setMass(mass);\r\n        }\r\n    });\r\n\r\n    const mass_sum = refGroup.sumMonomerStat('mass');\r\n\r\n    // Calculate weight percent for each comonomer using their individual mass and the mass sum\r\n    refGroup.getMonomers().forEach((monomer) => {\r\n        const wpercent = (monomer.getMass() / mass_sum) * 100.0;\r\n        monomer.setWeightPercent(wpercent);\r\n    });\r\n\r\n    // Calculations were successful for the Mole Percent Zipper Route\r\n    return true;\r\n}\r\n\r\nfunction ref_xsWeight(refGroup)\r\n{\r\n    // Find the reference monomer with mass and percent given\r\n    const ref_monomer = refGroup.findRefMonomer();\r\n\r\n    if (!ref_monomer) {\r\n        // There was no reference monomer\r\n        console.error(Error(`Cannot proceed calculations for ${refGroup.getName()} because there was no reference monomer`));\r\n        return false;\r\n    }\r\n\r\n    // This gives the ratio between mass and percent (e.g. 4 g for 40% means that 20% would be 2 g or that 55% would be 5.5 g)\r\n    const g_per_percent = ref_monomer.getMass() / ref_monomer.getWeightPercent();\r\n\r\n    // Iterate through each comonomer and calculate their mass and moles\r\n    for (let i = 0 ; i < refGroup.getMonomers().length ; i++)\r\n    {\r\n        const monomer = refGroup.getMonomers(i);\r\n\r\n        // If both mass and percent given, then check their ratio to the reference\r\n        if (monomer.massGiven() && monomer.weightPercentGiven()) {\r\n            const current_ratio = monomer.getMass() / monomer.getWeightPercent();\r\n            const wt_ratios_match = compareFloatValues(g_per_percent, current_ratio, ERROR_TOLERANCE);\r\n\r\n            if (!wt_ratios_match) {\r\n                // The ratio between mass and percent for one of the comonomers did not match the reference within the tolerance\r\n                console.error(Error(`Mass/Percent ratios don't match the reference for ${refGroup.getName()}...`));\r\n                return false;\r\n            }\r\n        }\r\n        // Mass is unknown, so calculate using ratio between mass and percent\r\n        else if (!monomer.massGiven() && monomer.weightPercentGiven()) {\r\n            const mass = monomer.getWeightPercent() * g_per_percent;\r\n            monomer.setMass(mass);\r\n        }\r\n        // Weight percent is unknown, so calculate using ratio between mass and percent\r\n        else if (monomer.massGiven() && !monomer.weightPercentGiven()) {\r\n            const wpercent = monomer.getMass() / g_per_percent;\r\n            monomer.setWeightPercent(wpercent);\r\n        }\r\n        // No `else` statement should be here to prevent preemptive calculations of the unknown comonomer\r\n\r\n        // Mass should be known, so calculate moles using molar mass\r\n        const moles = monomer.getMass() / monomer.getMolarMass();\r\n        monomer.setMoles(moles);\r\n    }\r\n\r\n    // Unknown can only be calculated once weight percent for all other comonomers values have been found\r\n    if (refGroup.hasUnknown()) {\r\n        // Find the partial weight percent sum, and get the unknown monomer\r\n        const part_percent_sum = refGroup.sumMonomerStat('wpercent');\r\n        const unknown_monomer = refGroup.getUnknown();\r\n\r\n        // Calculate unknown monomer's values\r\n        const unknown_wpercent = 100.0 - part_percent_sum;\r\n        const unknown_mass = unknown_wpercent * g_per_percent;\r\n        const unknown_moles = unknown_mass / unknown_monomer.getMolarMass();\r\n\r\n        // Set calculated unknown monomer values\r\n        unknown_monomer.setWeightPercent(unknown_wpercent);\r\n        unknown_monomer.setMass(unknown_mass);\r\n        unknown_monomer.setMoles(unknown_moles);\r\n    }\r\n\r\n    const mol_sum = refGroup.sumMonomerStat('moles');\r\n\r\n    refGroup.getMonomers().forEach((monomer) => {\r\n        // Calculating Ml% from moles and total moles\r\n        const mpercent = (monomer.getMoles() / mol_sum) * 100.0;\r\n        monomer.setMolePercent(mpercent);\r\n    });\r\n\r\n    // Calculations were successful for the Excess Weight Percent Route (or Tetris Route)\r\n    return true;\r\n}\r\n\r\nfunction ref_xsMole(refGroup)\r\n{\r\n    // Find the reference monomer with mass and percent given\r\n    const ref_monomer = refGroup.findRefMonomer();\r\n\r\n    if (!ref_monomer) {\r\n        // There was no reference monomer\r\n        console.error(Error(`Cannot proceed calculations for ${refGroup.getName()} because there was no reference monomer`));\r\n        return false;\r\n    }\r\n\r\n    // Calculate and set moles for reference comonomer, and use that value for the ratio between moles and percent\r\n    const reference_moles = ref_monomer.getMass() / ref_monomer.getMolarMass();\r\n    ref_monomer.setMoles(reference_moles);\r\n\r\n    // This gives the ratio between moles and percent (e.g. 0.04 mol for 40% means that 20% would be 0.02 mol or that 55% would be 0.055 mol)\r\n    const mol_per_percent = ref_monomer.getMoles() / ref_monomer.getMolePercent();\r\n\r\n    // Iterate through each comonomer and calculate their mass and moles\r\n    for (let i = 0 ; i < refGroup.getMonomers().length ; i++)\r\n    {\r\n        const monomer = refGroup.getMonomers(i);\r\n        \r\n        // If both mass and percent given, then check their ratio to the reference\r\n        if (monomer.massGiven() && monomer.molePercentGiven()) {\r\n            // Calculate the comonomer's moles\r\n            const moles = monomer.getMass() / monomer.getMolarMass();\r\n\r\n            const current_ratio = moles / monomer.getMolePercent();\r\n            const ml_ratios_match = compareFloatValues(mol_per_percent, current_ratio, ERROR_TOLERANCE);\r\n\r\n            if (ml_ratios_match) {\r\n                // The ratios match, so update the monomer's moles\r\n                monomer.setMoles(moles);\r\n            }\r\n            else {\r\n                // The ratio between mass and percent for one of the comonomers did not match the reference within the tolerance\r\n                console.error(Error(`Moles/Percent ratios don't match the reference for ${refGroup.getName()}...`));\r\n                return false;\r\n            }\r\n        }\r\n        // Mole percent is given but mass is undetermined, so calculate moles and mass using ratio between calculated moles and percent\r\n        else if (!monomer.massGiven() && monomer.molePercentGiven()) {\r\n            const moles = monomer.getMolePercent() * mol_per_percent;\r\n            const mass = moles * monomer.getMolarMass();\r\n            monomer.setMoles(moles);\r\n            monomer.setMass(mass);\r\n        }\r\n        // Mass is given but mole percent is undetermined, so calculate using ratio between calculated moles and percent\r\n        else if (monomer.massGiven() && !monomer.molePercentGiven()) {\r\n            const moles = monomer.getMass() / monomer.getMolarMass();\r\n            const mpercent = moles / mol_per_percent;\r\n            monomer.setMoles(moles);\r\n            monomer.setMolePercent(mpercent);\r\n        }\r\n        // No `else` statement should be here to prevent preemptive calculations of the unknown comonomer\r\n    }\r\n\r\n    // Unknown can only be calculated once mole percent for all other comonomers values have been found\r\n    if (refGroup.hasUnknown()) {\r\n        // Find the partial mole percent sum, and get the unknown monomer\r\n        const part_percent_sum = refGroup.sumMonomerStat('mpercent');\r\n        const unknown_monomer = refGroup.getUnknown();\r\n\r\n        // Calculate unknown monomer's values\r\n        const unknown_mpercent = 100.0 - part_percent_sum;\r\n        const unknown_moles = unknown_mpercent * mol_per_percent;\r\n        const unknown_mass = unknown_moles * unknown_monomer.getMolarMass();\r\n\r\n        // Set calculated unknown monomer values\r\n        unknown_monomer.setMolePercent(unknown_mpercent);\r\n        unknown_monomer.setMoles(unknown_moles);\r\n        unknown_monomer.setMass(unknown_mass);\r\n    }\r\n\r\n    const mass_sum = refGroup.sumMonomerStat('mass');\r\n\r\n    // Calculate weight percent for each comonomer using their individual mass and the mass sum\r\n    refGroup.getMonomers().forEach((monomer) => {\r\n        const wpercent = (monomer.getMass() / mass_sum) * 100.0;\r\n        monomer.setWeightPercent(wpercent);\r\n    });\r\n\r\n    // Calculations were successful for the Excess Mole Percent Route (or Tetris Route)\r\n    return true;\r\n}\r\n\r\n// Complimentary Calculations\r\nfunction comp_allPercent(refGroup, compGroup)\r\n{\r\n    // For partial percent sum calculations to find the unknown comonomer's percent\r\n    // Check that there is more than one comonomer in the complimentary group and that there is an unknown (n - 1 percents given)\r\n    if (compGroup.getNum() > 1 && compGroup.hasUnknown())\r\n    {\r\n        // The unknown monomer to find its percent value\r\n        const unknown_monomer = compGroup.getUnknown();\r\n\r\n        // The partial sum is defined by the given percent type chosen and its values given, so branch the path based on the chosen percent type\r\n        switch (compGroup.getPercentType())\r\n        {\r\n            case 'weight':\r\n                const part_wpercent_sum = compGroup.sumMonomerStat('wpercent');\r\n                \r\n                // Calculate the unknown comonomer's weight percent by finding the difference between the sum of every other's comonomer's weight percent and 100\r\n                const unknown_wpercent = 100.0 - part_wpercent_sum;\r\n                unknown_monomer.setWeightPercent(unknown_wpercent);\r\n                break;\r\n            case 'mole':\r\n                const part_mpercent_sum = compGroup.sumMonomerStat('mpercent');\r\n\r\n                // Calculate the unknown comonomer's mole percent by finding the difference between the sum of every other's comonomer's mole percent and 100\r\n                const unknown_mpercent = 100.0 - part_mpercent_sum;\r\n                unknown_monomer.setMolePercent(unknown_mpercent);\r\n                break;\r\n        }\r\n    }\r\n\r\n    // Calculate Weight Percent for groups with more than one comonomer\r\n    if (compGroup.getNum() > 1 && compGroup.getPercentType() === 'weight')\r\n    {\r\n        // Initialize the proportion sum and collection to put weight percents in terms of moles\r\n        var wtp_proportion_sum = 0.0; \r\n        const wtp_proportions = [];     // The indices of this array should match the comp group's monomers array\r\n\r\n        // Iterate through each comonomer in the complimentary group\r\n        compGroup.getMonomers().forEach((monomer) => {\r\n            // Put weight percent in terms of moles and set this comonomer's proportion\r\n            const wtp_proportion = monomer.getWeightPercent() / monomer.getMolarMass();\r\n            wtp_proportions.push(wtp_proportion);\r\n\r\n            // Add the calculated proportion to the current proportion total\r\n            wtp_proportion_sum += wtp_proportion;\r\n        });\r\n\r\n        // Calculate Mole Percent from Weight Percent using proportion\r\n        compGroup.getMonomers().forEach((monomer, proportion_index) => {\r\n            // Calculate mole percent using the ratio between an individual complimentary comonomer's proportion and the sum of those proportions\r\n            const mpercent = (wtp_proportions[proportion_index] / wtp_proportion_sum) * 100;\r\n            monomer.setMolePercent(mpercent);\r\n        });\r\n    }\r\n\r\n    // Find the mole sums for the complimentary group based on the their molar equivalents\r\n    const comp_mol_sum = (refGroup.sumMonomerStat('moles') / refGroup.getMolarEQ()) * compGroup.getMolarEQ();\r\n\r\n    // Iterate through complimentary group to calculate missing values (Moles & Mass)\r\n    compGroup.getMonomers().forEach((monomer) => {\r\n        // Mole percent is known and mass is unknown, so calculate moles then mass\r\n        const moles = comp_mol_sum * (monomer.getMolePercent() / 100.0);\r\n        const mass = moles * monomer.getMolarMass();\r\n        monomer.setMoles(moles);\r\n        monomer.setMass(mass);\r\n    });\r\n\r\n    // For mole percent calculations, calculate the still unknown weight percent values for each comonomer\r\n    if (compGroup.getPercentType() === 'mole')\r\n    {\r\n        const mass_sum = compGroup.sumMonomerStat('mass');\r\n        \r\n        // Calculate weight percent for each comonomer using their individual mass and the mass sum\r\n        compGroup.getMonomers().forEach((monomer) => {\r\n            const wpercent = (monomer.getMass() / mass_sum) * 100.0;\r\n            monomer.setWeightPercent(wpercent);\r\n        });\r\n    }\r\n\r\n    // Calculations were successful for the All Percent Route\r\n    return true;\r\n}\r\n\r\nfunction comp_givenMass(refGroup, compGroup)\r\n{\r\n    // Find the mole sums for the complimentary group based on the their molar equivalents\r\n    const comp_mol_sum = (refGroup.sumMonomerStat('moles') / refGroup.getMolarEQ()) * compGroup.getMolarEQ();\r\n    var part_mol_sum = 0.0, part_percent_sum = 0.0;\r\n\r\n    // Iterate through each given mass and calculate moles and mole percent, in addition to finding the partial mole and mole percent sums\r\n    compGroup.getMonomers().forEach((monomer) => {\r\n        if (monomer.massGiven())\r\n        {\r\n            // Calculate moles and mole percent from given mass\r\n            const moles = monomer.getMass() / monomer.getMolarMass();\r\n            const mpercent = (moles / comp_mol_sum) * 100.0;\r\n\r\n            // Set moles and mole percent\r\n            monomer.setMoles(moles);\r\n            monomer.setMolePercent(mpercent);\r\n\r\n            // Add calculated mole values to partial mole sums\r\n            part_mol_sum += moles;\r\n            part_percent_sum += mpercent;\r\n        }\r\n    });\r\n\r\n    // Check that the partial mole sum is less than the complimentary mole sum calculated using the reference mole sum\r\n    if (part_mol_sum >= comp_mol_sum) {\r\n        // The user's masses did not match the expected mole sum for the complimentary group\r\n        console.error(Error(\r\n            `The partial mole sum (${part_mol_sum} mol) for the complimentary (${compGroup.getName()}) group is greater than or equal to expected mole sum (${comp_mol_sum} mol). \r\n            \\nPlease enter valid masses or remove invalid ones.`\r\n        ));\r\n        return false;\r\n    }\r\n\r\n    // Get the unknown monomer, then calculate its mole percent, moles and mass\r\n    const unknown_monomer = compGroup.getUnknown();\r\n    const unknown_mpercent = 100.0 - part_percent_sum;\r\n    const unknown_moles = (unknown_mpercent / 100.0) * comp_mol_sum;\r\n    const unknown_mass = unknown_moles * unknown_monomer.getMolarMass();\r\n    // Set the unknown's calculated values\r\n    unknown_monomer.setMolePercent(unknown_mpercent);\r\n    unknown_monomer.setMoles(unknown_moles);\r\n    unknown_monomer.setMass(unknown_mass);\r\n\r\n    // All comonomer masses have been found, sum their values\r\n    const mass_sum = compGroup.sumMonomerStat('mass');\r\n\r\n    // Calculate weight percent for each comonomer using their individual mass and the mass sum\r\n    compGroup.getMonomers().forEach((monomer) => {\r\n        const wpercent = (monomer.getMass() / mass_sum) * 100.0;\r\n        monomer.setWeightPercent(wpercent);\r\n    });\r\n\r\n    // Calculations were successful for the Given Mass Route\r\n    return true;\r\n}\r\n\r\nfunction comp_mlpZipper(refGroup, compGroup)\r\n{\r\n    // Find the mole sums for the complimentary group based on the their molar equivalents\r\n    const comp_mol_sum = (refGroup.sumMonomerStat('moles') / refGroup.getMolarEQ()) * compGroup.getMolarEQ();\r\n    var part_percent_sum = 0.0, calc_mol_sum = 0.0;\r\n\r\n    // Iterate through each comonomer with either mass or mole percent known\r\n    compGroup.getMonomers().forEach((monomer) => {\r\n        // Mole percent is known, so calculate moles and then mass\r\n        if (monomer.molePercentGiven())\r\n        {\r\n            const moles = comp_mol_sum * (monomer.getMolePercent() / 100.0);\r\n            const mass = moles * monomer.getMolarMass();\r\n            // Add calculated moles to the calculated mole sum representing the user's given values\r\n            calc_mol_sum += moles;\r\n\r\n            // Set moles and mass\r\n            monomer.setMoles(moles);\r\n            monomer.setMass(mass);\r\n        }\r\n        // Mass is known, so calculate moles and then mole percent\r\n        else if (monomer.massGiven())\r\n        {\r\n            const moles = monomer.getMass() / monomer.getMolarMass();\r\n            const mpercent = (moles / comp_mol_sum) * 100.0;\r\n            // Add this comonomer's mass to the partial mole sum and calculated mole sum representing the user's given values\r\n            calc_mol_sum += moles;\r\n\r\n            // Set moles and mole percent\r\n            monomer.setMoles(moles);\r\n            monomer.setMolePercent(mpercent);\r\n        }\r\n\r\n        // Add calculated/given mole percent to partial percent sum\r\n        part_percent_sum += monomer.getMolePercent();\r\n    });\r\n\r\n    // Check that the calculated mole sum is less than the expected mole sum since calculations are still incomplete\r\n    const part_mol_sum_valid = calc_mol_sum < comp_mol_sum;\r\n\r\n    if (!part_mol_sum_valid) {\r\n        // The user's masses exceeded the expected mole sum for the complimentary group\r\n        console.error(Error(\r\n            `Partial mole sum exceeded the expected mole sum for the complimentary (${compGroup.getName()}) group. \r\n            \\nPlease enter valid masses or remove invalid ones.`\r\n        ));\r\n        return false;\r\n    }\r\n\r\n    // Check that the partial percent sum is less than 100\r\n    const part_percent_sum_valid = part_percent_sum < 100.0;\r\n\r\n    if (!part_percent_sum_valid) {\r\n        // The calculated sum of all mole percents exceeded 100 for the complimentary group\r\n        console.error(Error(\r\n            `Calculated sum of all mole percents (${part_percent_sum}%) exceeded 100% for the complimentary (${compGroup.getName()}) group. \r\n            \\nPlease enter valid masses/percents or remove invalid ones.`\r\n        ));\r\n        return false;\r\n    }\r\n\r\n    // Get the unknown monomer, then calculate its mole percent, moles and mass\r\n    const unknown_monomer = compGroup.getUnknown();\r\n    const unknown_mpercent = 100.0 - part_percent_sum;\r\n    const unknown_moles = (unknown_mpercent / 100.0) * comp_mol_sum;\r\n    const unknown_mass = unknown_moles * unknown_monomer.getMolarMass();\r\n    // Add the unknown's found moles to the calculated mole sum and make sure the calculated mole sum is equivalent to the expected mole sum\r\n    calc_mol_sum += unknown_moles;\r\n    const calc_mol_sum_valid = compareFloatValues(comp_mol_sum, calc_mol_sum, ERROR_TOLERANCE);\r\n\r\n    if (!calc_mol_sum_valid) {\r\n        // The user's masses exceeded the expected mole sum for the complimentary group\r\n        console.error(Error(\r\n            `Calculated mole sum exceeded the expected mole sum for the complimentary (${compGroup.getName()}) group. \r\n            \\nPlease enter valid masses or remove invalid ones.`\r\n        ));\r\n        return false;\r\n    }\r\n    // Set the unknown's calculated values\r\n    unknown_monomer.setMolePercent(unknown_mpercent);\r\n    unknown_monomer.setMoles(unknown_moles);\r\n    unknown_monomer.setMass(unknown_mass);\r\n\r\n    // All comonomer masses have been found, sum their values\r\n    const mass_sum = compGroup.sumMonomerStat('mass');\r\n\r\n    // Calculate weight percent for each comonomer using their individual mass and the mass sum\r\n    compGroup.getMonomers().forEach((monomer) => {\r\n        const wpercent = (monomer.getMass() / mass_sum) * 100.0;\r\n        monomer.setWeightPercent(wpercent);\r\n    });\r\n\r\n    // Calculations were successful for the Mole Percent Zipper Route\r\n    return true;\r\n}\r\n\r\nfunction comp_wtpZipper(refGroup, compGroup)\r\n{\r\n    // Find the mole sums for the complimentary group based on the their molar equivalents\r\n    const comp_mol_sum = (refGroup.sumMonomerStat('moles') / refGroup.getMolarEQ()) * compGroup.getMolarEQ();\r\n\r\n    var part_percent_sum = 0.0,                 // Indicates the weight percent occupied by comonomer(s) with known mass in addition to the unknown comonomer\r\n        part_mol_sum = comp_mol_sum,            // Initialized with complimentary mole sum, decremented by calculated moles\r\n        unknown_mol_offset = 0.0,               // Found value by putting known masses in terms of the unknown monomer's molar mass\r\n        percent_contribution_to_mol_sum = 0.0;  // Indicates how much weight percents contribute to the total mole sum\r\n\r\n    // Get the complimentary group's unknown monomer\r\n    const unknown_monomer = compGroup.getUnknown();\r\n\r\n    for (let i = 0 ; i < compGroup.getMonomers().length ; i++) \r\n    {\r\n        const monomer = compGroup.getMonomers(i);\r\n\r\n        // Mass is known, so calculate moles and then mole percent\r\n        if (monomer.massGiven())\r\n        {\r\n            // Mass is given, so calculate moles and mole percent\r\n            const moles = monomer.getMass() / monomer.getMolarMass();\r\n            const mpercent = (moles / comp_mol_sum) * 100.0;\r\n\r\n            // Divide this monomer's mass by the unknown comonomer's molar mass\r\n            unknown_mol_offset += monomer.getMass() / unknown_monomer.getMolarMass();\r\n\r\n            // Subtract this monomer's moles from the partial mole sum to find the moles accounted by the weight percents and unknown comonomer\r\n            part_mol_sum -= moles;\r\n\r\n            // Make sure that partial mole sum is greater than 0\r\n            if (part_mol_sum <= 0.0) {\r\n                // The calculated moles from given masses are invalid for the complimentary group\r\n                console.error(Error(\r\n                    `Calculated moles from given masses are invalid for the complimentary (${compGroup.getName()}) group. \r\n                    \\nPlease enter valid masses or remove invalid ones.`\r\n                ));\r\n                return false;\r\n            }\r\n\r\n            // Set the monomer's calculated moles and mole percent\r\n            monomer.setMoles(moles);\r\n            monomer.setMolePercent(mpercent);\r\n        }\r\n        // Weight Percent is known, so calculate the weight percent's contribution to the total moles\r\n        else if (monomer.weightPercentGiven())\r\n        {\r\n            const percent_contribution = (monomer.getWeightPercent() / 100.0) / monomer.getMolarMass(); // formerly `wumbo_factor`\r\n            percent_contribution_to_mol_sum += percent_contribution;\r\n\r\n            // Add this weight percent to the partial percent sum to find the weight percent occupied by the known masses and unknown comonomer\r\n            part_percent_sum += monomer.getWeightPercent();\r\n        }\r\n    }\r\n\r\n    // Find the moles contributed by the comonomers with weight percent given in addition to the unknown comonomer's moles\r\n    const all_non_mass_mol_contribution = percent_contribution_to_mol_sum + (((100.0 - part_percent_sum) / 100.0) / unknown_monomer.getMolarMass());\r\n    const mass_sum = (part_mol_sum + unknown_mol_offset) / all_non_mass_mol_contribution;\r\n\r\n    // Initialize calculated mole sum with partial mole sum\r\n    let calc_mol_sum = part_mol_sum;        // Any moles calculated with given percent will be added to this\r\n    let calc_mass_sum = 0.0;                // Makes sure that the calculated mass sum matches the expected mass sum previously calculated\r\n\r\n    compGroup.getMonomers().forEach((monomer) => {\r\n        // For known masses, calculate their weight percents using the mass sum\r\n        if (monomer.massGiven())\r\n        {\r\n            const wpercent = (monomer.getMass() / mass_sum) * 100.0;\r\n            // Add calculated weight percent to partial percent sum and update the monomer\r\n            part_percent_sum += wpercent;\r\n            monomer.setWeightPercent(wpercent);\r\n        }\r\n        // For known weight percents, calculate their mass using the mass sum, then their moles and mole percent\r\n        else if (monomer.weightPercentGiven())\r\n        {\r\n            const mass = (monomer.getWeightPercent() / 100.0) * mass_sum;\r\n            const moles = mass / monomer.getMolarMass();\r\n            const mpercent = (moles / comp_mol_sum) * 100.0;\r\n\r\n            // Add calculated moles to calculated mole sum and update the monomer\r\n            calc_mol_sum += moles;\r\n            monomer.setMass(mass);\r\n            monomer.setMoles(moles);\r\n            monomer.setMolePercent(mpercent);\r\n        }\r\n\r\n        // Add this comonomer's calculated/given mass to the calculated mass sum\r\n        calc_mass_sum += monomer.getMass();\r\n    });\r\n\r\n    // Check that the calculated mass sum is less than the expected mass sum\r\n    const user_mass_sum_valid = mass_sum > calc_mass_sum;\r\n\r\n    if (!user_mass_sum_valid) {\r\n        // The calculated mass sum exceeded the expected mass sum for the complimentary group\r\n        console.error(Error(\r\n            `Calculated mass sum (${calc_mass_sum} g) exceeded or equaled the expected mass sum (${mass_sum} g) for the complimentary (${compGroup.getName()}) group. \r\n            \\nPlease enter valid masses or remove invalid ones.`\r\n        ));\r\n        return false;\r\n    }\r\n\r\n    // Check that the calculated mole sum does not exceed or equal the expected mole sum \r\n    const user_mol_sum_valid = comp_mol_sum > calc_mol_sum;\r\n                \r\n    if (!user_mol_sum_valid) {\r\n        // The user's masses exceeded the expected mole sum for the complimentary group\r\n        console.error(Error(\r\n            `Calculated mole sum (${calc_mol_sum} mol) exceeded or equaled the expected mole sum (${comp_mol_sum} mol) for the complimentary (${compGroup.getName()}) group. \r\n            \\nPlease enter valid masses or remove invalid ones.`\r\n        ));\r\n        return false;\r\n    }\r\n\r\n    // Check that the partial percent sum is less than 100\r\n    const part_percent_sum_valid = part_percent_sum < 100.0;\r\n                \r\n    if (!part_percent_sum_valid) {\r\n        // The calculated sum of all mole percents exceeded 100 for the complimentary group\r\n        console.error(Error(\r\n            `Calculated sum of all mole percents (${part_percent_sum}%) exceeded 100 for the complimentary (${compGroup.getName()}) group. \r\n            \\nPlease enter valid masses or remove invalid ones.`\r\n        ));\r\n        return false;\r\n    }\r\n\r\n    // Calculate wt%, mass, moles, and ml% for unknown comonomer\r\n    const unknown_wpercent = 100.0 - part_percent_sum;\r\n    const unknown_mass = (unknown_wpercent / 100.0) * mass_sum;\r\n    const unknown_moles = unknown_mass / unknown_monomer.getMolarMass();\r\n    const unknown_mpercent = (unknown_moles / comp_mol_sum) * 100.0;\r\n    // Set calculated values for unknown comonomer\r\n    unknown_monomer.setWeightPercent(unknown_wpercent);\r\n    unknown_monomer.setMass(unknown_mass);\r\n    unknown_monomer.setMoles(unknown_moles);\r\n    unknown_monomer.setMolePercent(unknown_mpercent);\r\n\r\n    // Calculations were successful for the Weight Percent Zipper Route\r\n    return true;\r\n}\r\n\r\nfunction comp_mlpXS(refGroup, compGroup)\r\n{\r\n    // Find the mole sums for the complimentary group based on the their molar equivalents\r\n    const comp_mol_sum = (refGroup.sumMonomerStat('moles') / refGroup.getMolarEQ()) * compGroup.getMolarEQ();\r\n\r\n    // Validate any masses given and calculate any possible values (e.g. moles)\r\n    const { calc_complete, calc_failed } = xsInfo_validateMasses(compGroup, comp_mol_sum);\r\n\r\n    // Check if calculations are complete and that there were no problems\r\n    if (calc_failed) {\r\n        // There was a problem with the masses given\r\n        return false;\r\n    }\r\n    else if (calc_complete && !calc_failed) {\r\n        // The calculations succeeded and no more are necessary\r\n        return true;\r\n    }\r\n\r\n    /********************************************************************************************************************\r\n     * There is more than one comonomer, so check the ratios between mass and percent for those which give both values  *\r\n     * (the ratio between different comonomers and their percents may differ and lead to error depending on user input) *\r\n     ********************************************************************************************************************/\r\n    \r\n    // List of comonomers with mass and mole percent given\r\n    const determined_comonomers = compGroup.getMonomers()\r\n        .filter((monomer) => monomer.massGiven() && monomer.molePercentGiven());\r\n\r\n    // For complimentary group with more than one comonomer and at least one comonomer with both mass and percent given\r\n    if (determined_comonomers.length >= 1) \r\n    {\r\n        // Because mole percent was chosen, a given mole percent may not match the expected mole percent based on the calculated moles of each given mass\r\n        for (let i = 0 ; i < determined_comonomers.length ; i++) \r\n        {\r\n            const monomer = determined_comonomers[i];\r\n    \r\n            const expected_mpercent = monomer.getMoles() / comp_mol_sum;\r\n            const given_mpercent = monomer.getMolePercent();\r\n\r\n            // Validate that the user's mole percent is equivalent to the expected mole percent within reasonable error\r\n            const mpercents_match = compareFloatValues(expected_mpercent, given_mpercent, ERROR_TOLERANCE);\r\n\r\n            if (!mpercents_match) {\r\n                // The given mole percents do not match the expected mole percent\r\n                console.error(Error(\r\n                    `The given mole percents do not match the expected mole percent for the complimentary (${compGroup.getName()}) group. \r\n                    \\nPlease enter valid masses or remove invalid ones.`\r\n                ));\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Set the reference comonomer to the first one in the index. Any ratio value which differ from this reference are invalid\r\n        const [ reference_monomer ] = determined_comonomers;\r\n        const reference_ratio = reference_monomer.getMoles() / reference_monomer.getMolePercent();\r\n\r\n        for (let i = 0 ; i < determined_comonomers.length ; i++) \r\n        {\r\n            const monomer = determined_comonomers[i];\r\n            const mol_per_percent = monomer.getMoles() / monomer.getMolePercent();\r\n\r\n            // Validate that the user's mole ratio is equivalent to the reference ratio within reasonable error\r\n            const ml_ratios_match = compareFloatValues(reference_ratio, mol_per_percent, ERROR_TOLERANCE);\r\n\r\n            if (!ml_ratios_match) {\r\n                console.error(Error(\r\n                    `The ratios between calculated moles and percents did not all match for the complimentary (${compGroup.getName()}) group. \r\n                    \\nPlease enter valid masses or remove invalid ones.`\r\n                ));\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // No issues detected with ratios, so calculate remaining undetermined mole percent and mass/moles values\r\n        if (determined_comonomers.length < compGroup.getNum())\r\n        {\r\n            compGroup.getMonomers().forEach((monomer) => {\r\n                // Mass is given but mole percent is unknown, so calculate mole percent using moles and mole sum\r\n                if(monomer.massGiven() && !monomer.molePercentGiven()) {\r\n                    const mpercent = monomer.getMoles() / reference_ratio;\r\n                    monomer.setMolePercent(mpercent);\r\n                } \r\n                // Mole percent is given but mass is unknown, so calculate mass then moles using reference ratio\r\n                else if (!monomer.massGiven() && monomer.molePercentGiven()) {\r\n                    const moles = monomer.getMolePercent() * reference_ratio;\r\n                    const mass = moles * monomer.getMolarMass();\r\n                    monomer.setMoles(moles);\r\n                    monomer.setMass(mass);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Check for an unknown, and calculate its missing values if it exists\r\n        if (compGroup.hasUnknown()) {\r\n            const unknown_monomer = compGroup.getUnknown();\r\n            const part_mlp_sum = compGroup.sumMonomerStat('mpercent');\r\n\r\n            if (part_mlp_sum >= 100.0) \r\n            {\r\n                // The calculated sum of all weight percents exceeded 100 for the complimentary group\r\n                console.error(Error(\r\n                    `Calculated sum of all mole percents (${part_mlp_sum}%) exceeded 100 for the complimentary (${compGroup.getName()}) group. \r\n                    \\nPlease enter valid masses or remove invalid ones.`\r\n                ));\r\n                return false;\r\n            }\r\n\r\n            const unknown_mpercent = 100.0 - part_mlp_sum;\r\n            const unknown_moles = unknown_mpercent * reference_ratio;\r\n            const unknown_mass = unknown_moles * unknown_monomer.getMolarMass();\r\n            unknown_monomer.setMolePercent(unknown_mpercent);\r\n            unknown_monomer.setMoles(unknown_moles);\r\n            unknown_monomer.setMass(unknown_mass);\r\n        }\r\n\r\n        const mass_sum = compGroup.sumMonomerStat('mass');\r\n\r\n        // All masses should have been calculated, so find weight percents using calculated mass sum\r\n        compGroup.getMonomers().forEach((monomer) => {\r\n            const wpercent = (monomer.getMass() / mass_sum) * 100.0;\r\n            monomer.setWeightPercent(wpercent);\r\n        });\r\n\r\n        // Calculations were successful for the Excess Mass Route\r\n        return true;\r\n    }\r\n    // For complimentary group with a configuration similar to reference Zipper Route\r\n    else {\r\n        // There are no reference comonomers with both mass and percent given, nor are all masses given, so calculate using ratio between the sum of masses and the remaining percent left\r\n        const part_mlp_sum = compGroup.sumMonomerStat('mpercent');\r\n        const part_mole_sum = compGroup.sumMonomerStat('moles');\r\n        const mol_per_percent = part_mole_sum / (100.0 - part_mlp_sum);\r\n\r\n        compGroup.getMonomers().forEach((monomer) => {\r\n            // Mass is known (moles were already calculated previously), so calculate the value for mole percent\r\n            if (!monomer.molePercentGiven() && monomer.massGiven()) {\r\n                const mpercent = monomer.getMoles() / mol_per_percent;\r\n                monomer.setMolePercent(mpercent);\r\n            }\r\n            // Mole Percent is known, so calculate the value for mass and moles\r\n            if (monomer.molePercentGiven() && !monomer.massGiven()) {\r\n                const moles = monomer.getMolePercent() * mol_per_percent;\r\n                const mass = moles * monomer.getMolarMass();\r\n                monomer.setMoles(moles);\r\n                monomer.setMass(mass);\r\n            }\r\n        });\r\n\r\n        // Check that the mole sum matches the expected mole sum within reasonable error\r\n        const user_mol_sum = compGroup.sumMonomerStat('moles');\r\n        const user_mol_sum_valid = compareFloatValues(comp_mol_sum, user_mol_sum, ERROR_TOLERANCE);\r\n\r\n        if (!user_mol_sum_valid) {\r\n            // The user's masses did not match the expected mole sum for the complimentary group\r\n            console.error(Error(\r\n                `The masses given did not match the calculated mole sum for the complimentary (${compGroup.getName()}) group. \r\n                \\nPlease enter valid masses or remove invalid ones.`\r\n            ));\r\n            return false;\r\n        }\r\n\r\n        // Calculations were successful for the Excess Mass Route\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction comp_wtpXS(refGroup, compGroup)\r\n{\r\n    // Find the mole sums for the complimentary group based on the their molar equivalents\r\n    const comp_mol_sum = (refGroup.sumMonomerStat('moles') / refGroup.getMolarEQ()) * compGroup.getMolarEQ();\r\n\r\n    // Validate any masses given and calculate any possible values (e.g. moles)\r\n    const { calc_complete, calc_failed } = xsInfo_validateMasses(compGroup, comp_mol_sum);\r\n\r\n    // Check if calculations are complete and that there were no problems\r\n    if (calc_failed) {\r\n        // There was a problem with the masses given\r\n        return false;\r\n    }\r\n    else if (calc_complete && !calc_failed) {\r\n        // The calculations succeeded and no more are necessary\r\n        return true;\r\n    }\r\n\r\n    /********************************************************************************************************************\r\n     * There is more than one comonomer, so check the ratios between mass and percent for those which give both values  *\r\n     * (the ratio between different comonomers and their percents may differ and lead to error depending on user input) *\r\n     ********************************************************************************************************************/\r\n    \r\n    // List of comonomers with mass and weight percent given\r\n    const determined_comonomers = compGroup.getMonomers()\r\n        .filter((monomer) => monomer.massGiven() && monomer.weightPercentGiven());\r\n\r\n    // For complimentary group with more than one comonomer and at least one comonomer with both mass and percent given\r\n    if (determined_comonomers.length >= 1) \r\n    {\r\n        /**************************************************************\r\n         *  CHECK RATIOS BETWEEN MASS/MOLES AND THEIR PERCENT VALUES  *\r\n         **************************************************************/\r\n\r\n        // Set the reference comonomer to the first one in the index. Any ratio value which differ from this reference are invalid\r\n        const [ reference_monomer ] = determined_comonomers;\r\n        const reference_ratio = reference_monomer.getMass() / reference_monomer.getWeightPercent();\r\n\r\n        // Check ratios of mass to percent for comonomers with both given\r\n        for (let i = 0 ; i < determined_comonomers.length ; i++) \r\n        {\r\n            const monomer = determined_comonomers[i];\r\n            const g_per_percent = monomer.getMass() / monomer.getWeightPercent();\r\n\r\n            // Validate that the user's weight ratio is equivalent to the reference ratio within reasonable error\r\n            const wt_ratios_match = compareFloatValues(reference_ratio, g_per_percent, ERROR_TOLERANCE);\r\n\r\n            if (!wt_ratios_match) {\r\n                // The given weight ratios do not match the reference ratio\r\n                console.error(Error(\r\n                    `The given weight percents do not match the expected weight ratio for the complimentary (${compGroup.getName()}) group. \r\n                    \\nPlease enter valid masses or remove invalid ones.`\r\n                ));\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // No issues detected with ratios, so calculate remaining undetermined weight percent values\r\n        if (determined_comonomers.length < compGroup.getNum())\r\n        {\r\n            compGroup.getMonomers().forEach((monomer) => {\r\n                // Mass is given but weight percent is unknown, so calculate weight percent using reference ratio\r\n                if(monomer.massGiven() && !monomer.weightPercentGiven()) {\r\n                    const wpercent = monomer.getMass() / reference_ratio;\r\n                    monomer.setWeightPercent(wpercent);\r\n                } \r\n                // Weight percent is given but mass is unknown, so calculate mass then moles using reference ratio\r\n                else if (!monomer.massGiven() && monomer.weightPercentGiven()) {\r\n                    const mass = monomer.getWeightPercent() * reference_ratio;\r\n                    const moles = mass / monomer.getMolarMass();\r\n                    monomer.setMass(mass);\r\n                    monomer.setMoles(moles);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Check for an unknown, and calculate its missing values if it exists\r\n        if (compGroup.hasUnknown())\r\n        {\r\n            const unknown_monomer = compGroup.getUnknown();\r\n            const part_wtp_sum = compGroup.sumMonomerStat('wpercent');\r\n\r\n            if (part_wtp_sum >= 100.0) \r\n            {\r\n                // The calculated sum of all weight percents exceeded 100 for the complimentary group\r\n                console.error(Error(\r\n                    `Calculated sum of all weight percents (${part_wtp_sum}%) exceeded 100 for the complimentary (${compGroup.getName()}) group. \r\n                    \\nPlease enter valid masses or remove invalid ones.`\r\n                ));\r\n                return false;\r\n            }\r\n\r\n            const unknown_wpercent = 100.0 - part_wtp_sum;\r\n            const unknown_mass = unknown_wpercent * reference_ratio;\r\n            const unknown_moles = unknown_mass / unknown_monomer.getMolarMass();\r\n            unknown_monomer.setWeightPercent(unknown_wpercent);\r\n            unknown_monomer.setMass(unknown_mass);\r\n            unknown_monomer.setMoles(unknown_moles);\r\n        }\r\n\r\n        // All moles should have been calculated, so find mole percents using calculated mole sum\r\n        compGroup.getMonomers().forEach((monomer) => {\r\n            const mpercent = (monomer.getMoles() / comp_mol_sum) * 100.0;\r\n            monomer.setMolePercent(mpercent);\r\n        });\r\n\r\n        // Calculations were successful for the Excess Mass Route\r\n        return true;\r\n    }\r\n    // For complimentary group with a configuration similar to reference Zipper Route\r\n    else {\r\n        // There are no reference comonomers with both mass and percent given, nor are all masses given, so calculate using ratio between the sum of masses and the remaining percent left\r\n        const part_wtp_sum = compGroup.sumMonomerStat('wpercent');\r\n        const part_mass_sum = compGroup.sumMonomerStat('mass');\r\n        const g_per_percent = part_mass_sum / (100.0 - part_wtp_sum);\r\n\r\n        compGroup.getMonomers().forEach((monomer) => {\r\n            // Mass is known, so calculate the value for weight percent\r\n            if (!monomer.weightPercentGiven() && monomer.massGiven()) {\r\n                const wpercent = monomer.getMass() / g_per_percent;\r\n                monomer.setWeightPercent(wpercent);\r\n            }\r\n            // Weight percent is known, so calculate the value for mass\r\n            else if (monomer.weightPercentGiven() && !monomer.massGiven()) {\r\n                const mass = monomer.getWeightPercent() * g_per_percent;\r\n                const moles = mass / monomer.getMolarMass();\r\n                monomer.setMass(mass);\r\n                monomer.setMoles(moles);\r\n            }\r\n        });\r\n\r\n        // Check that the mole sum matches the expected mole sum within reasonable error\r\n        const user_mol_sum = compGroup.sumMonomerStat('moles');\r\n        const user_mol_sum_valid = compareFloatValues(comp_mol_sum, user_mol_sum, ERROR_TOLERANCE);\r\n\r\n        if (!user_mol_sum_valid) {\r\n            // The user's masses did not match the expected mole sum for the complimentary group\r\n            console.error(Error(\r\n                `The masses given did not match the calculated mole sum for the complimentary (${compGroup.getName()}) group. \r\n                \\nPlease enter valid masses or remove invalid ones.`\r\n            ));\r\n            return false;\r\n        }\r\n\r\n        // Calculations were successful for the Excess Mass Route\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction xsInfo_validateMasses(compGroup, comp_mol_sum)\r\n{\r\n    let user_mol_sum = 0;\r\n    const ALL_MASSES_GIVEN = compGroup.getMonomerStatCount('mass') === compGroup.getNum();\r\n    const NO_PERCENT_GIVEN = compGroup.getMonomerStatCount('percent') === 0;\r\n\r\n    // Calculate the moles of masses given by the user and add to user mol sum\r\n    compGroup.getMonomers().forEach((monomer) => {\r\n        if (monomer.massGiven())\r\n        {\r\n            const moles = monomer.getMass() / monomer.getMolarMass();\r\n            user_mol_sum += moles;\r\n            monomer.setMoles(moles);\r\n        }\r\n    });\r\n\r\n    // Validate that the masses given follow the expected mole sum\r\n    if (ALL_MASSES_GIVEN)\r\n    {\r\n        // Validate that the user's mole sum is equivalent to the calculated mole sum within reasonable error\r\n        const user_mol_sum_valid = compareFloatValues(comp_mol_sum, user_mol_sum, ERROR_TOLERANCE);\r\n\r\n        if (!user_mol_sum_valid) {\r\n            // The user's masses exceeded the expected mole sum for the complimentary group\r\n            console.error(Error(\r\n                `Calculated mole sum exceeded the expected mole sum for the complimentary (${compGroup.getName()}) group. \r\n                \\nPlease enter valid masses or remove invalid ones.`\r\n            ));\r\n            return { calc_complete: false, calc_failed: true };\r\n        }\r\n    }\r\n    else \r\n    {\r\n        // Not all masses were given, so user mole sum should be less than expected mole sum\r\n        const user_mol_sum_valid = comp_mol_sum > user_mol_sum;\r\n\r\n        if (!user_mol_sum_valid) {\r\n            // The user's masses exceeded the expected mole sum for the complimentary group\r\n            console.error(Error(\r\n                `Calculated mole sum must be less than the expected mole sum for the complimentary (${compGroup.getName()}) group. \r\n                \\nPlease enter valid masses or remove invalid ones.`\r\n            ));\r\n            return { calc_complete: false, calc_failed: true };\r\n        }\r\n    }\r\n\r\n    // If there is only one monomer (mass must be given to to use this calc route)\r\n    if (compGroup.getNum() === 1) {\r\n        // No more calculations are necessary\r\n        return { calc_complete: true, calc_failed: false };\r\n    }\r\n    // For complimentary group with more than one comonomer and all masses given, but no percents given\r\n    else if (ALL_MASSES_GIVEN && NO_PERCENT_GIVEN) {\r\n        // All masses were given and all moles were calculated and validated\r\n        const mass_sum = compGroup.sumMonomerStat('mass');\r\n        \r\n        // Calculate mole percent and weight percent\r\n        compGroup.getMonomers().forEach((monomer) => {\r\n            const wpercent = (monomer.getMass() / mass_sum) * 100.0;\r\n            const mpercent = (monomer.getMoles() / comp_mol_sum) * 100.0;\r\n            monomer.setWeightPercent(wpercent);\r\n            monomer.setMolePercent(mpercent);\r\n        });\r\n\r\n        // No more calculations are necessary\r\n        return { calc_complete: true, calc_failed: false };\r\n    }\r\n\r\n    // The prior checks did not return out of the function, so there are no problems but more calculations are required\r\n    return { calc_complete: false, calc_failed: false };\r\n}","import React from 'react';\r\nimport { useFuncGroups, useFuncDispatch } from '../../contexts/FuncContext';\r\nimport { UPDATE_FUNC, UPDATE_MONOMERS } from '../../contexts/actions';\r\nimport { FUNC_FORM, MONOMER_FORM, FINAL_RESULTS } from '../../contexts/page_names';\r\n\r\n// Import FuncGroup Class for defining input data\r\nimport Monomer from '../../utils/Monomer';\r\n// Functions for determining calculation routes and performing calculations\r\nimport { startDataSorting } from '../../utils/data_sorting';\r\nimport { doReferenceCalculations, doComplimentaryCalculations } from '../../utils/func_calculations';\r\n// Import validator functions and error message generation\r\nimport { checkDataTypes, compareFloatValues } from '../../utils/validators';\r\nimport { invalidErrorMessage } from '../../utils/helpers';\r\n// Import ornamental functions for improving displayed data\r\nimport { capitalizeFirstLetter } from '../../utils/ornaments';\r\nimport { ERROR_TOLERANCE } from '../../utils/standards';\r\n\r\nexport default function FuncGroupForm()\r\n{\r\n    const { formData, funcGroups } = useFuncGroups();\r\n    const { setFormData, setFuncGroup, setPage } = useFuncDispatch();\r\n    \r\n    const handleFormChange = (event) => {\r\n        const { name, value } = event.target;\r\n        \r\n        // Update form field to new value\r\n        setFormData({ formType: MONOMER_FORM, formField: name, value });\r\n    }\r\n\r\n    const handleFormSubmission = () => {\r\n        // Contains the monomers for both functional groups as two separate arrays\r\n        const parsedMonomers = funcGroups.map(({ name, num, percent_type }, funcGroupIndex) => {\r\n            // Lists the monomers for this particular functional group\r\n            let funcGroupMonomers = [];\r\n            const funcName = capitalizeFirstLetter(name);\r\n\r\n            // Track the number of unknowns per functional group !THERE CAN ONLY BE UP TO 1 UNKNOWN PER FUNCTIONAL GROUP\r\n            let unknownCount = [0, 0];\r\n            // Track that all given inputs are acceptable\r\n            let inputsAcceptable = true;\r\n            // Track the Percent Sum (should be less than 100 if not all percents given, should be 100 if all percents given)\r\n            let percentsGiven = 0;\r\n            let percentSum = 0.0;\r\n\r\n            for (let i = 0 ; i < num ; i++)\r\n            {\r\n                const monomerName = `${funcName}-${i + 1}`;\r\n                const { monomersForm } = formData;\r\n                \r\n                // Get given monomer form values, accessed with key value, identified by monomer name\r\n                const given_mass = monomersForm[`mass${monomerName}`];\r\n                const given_percent = monomersForm[`percent${monomerName}`];\r\n                const given_molar_mass = monomersForm[`molar_mass${monomerName}`];\r\n\r\n                // Set mass, percent, and molar mass values depending on input given\r\n                const mass = given_mass === '' ? 0 : parseFloat(given_mass);\r\n                const percent = given_percent === '' ? 0 : parseFloat(given_percent);\r\n                const molar_mass = given_molar_mass === '' ? 0 : parseFloat(given_molar_mass);\r\n\r\n                // Check that input values are acceptable and the correct datatype\r\n                const massAcceptable = checkDataTypes('float', { value: mass, isMonomer: true });\r\n                const percentAcceptable = checkDataTypes('float', { value: percent, isMonomer: true });\r\n                const molar_massAcceptable = checkDataTypes('float', { value: molar_mass, isMonomer: true });\r\n\r\n                // Set weight percent value depending on given conditions\r\n                const weight_percent = percentAcceptable && percent_type === 'weight'\r\n                    // Set this monomer to the given percent value\r\n                    ? num === 1 ? 100 : percent   \r\n                    // Set weight percent to 0 to indicate that it is undetermined\r\n                    : num === 1 ? 100 : 0;\r\n                \r\n                // Set mole percent value depending on given conditions\r\n                const mole_percent = percentAcceptable && percent_type === 'mole'\r\n                    // Set this monomer to the given percent value\r\n                    ? num === 1 ? 100 : percent   \r\n                    // Set weight percent to 0 to indicate that it is undetermined\r\n                    : num === 1 ? 100 : 0;  \r\n                    \r\n                // Add the given percent to the percent sum\r\n                percentSum += percent_type === 'weight' ? weight_percent : mole_percent;\r\n                if (weight_percent > 0 || mole_percent > 0) percentsGiven++;\r\n                const allPercentsEntered = percentsGiven === num;\r\n                const percentsSumValid = allPercentsEntered \r\n                    ? compareFloatValues(100.0, percentSum, ERROR_TOLERANCE)\r\n                    : percentSum < 100.0;\r\n\r\n                // Check if mass and percents are unknown\r\n                if (mass === 0 && weight_percent === 0 && mole_percent === 0) \r\n                {\r\n                    unknownCount[funcGroupIndex] += 1;\r\n                    funcGroups[funcGroupIndex].setUnknown(i);\r\n\r\n                    if (unknownCount[funcGroupIndex] > 1)\r\n                    {\r\n                        // There can only be up to 1 unknown in a functional group\r\n                        console.error(invalidErrorMessage('less than or equal to 1', 'Unknowns'));\r\n                        inputsAcceptable = false;\r\n                    }\r\n                }\r\n\r\n                // Check if molar mass is unknown (for molar mass to be given, it must be greater than 0)\r\n                if (!molar_mass > 0)\r\n                {\r\n                    console.error(invalidErrorMessage('greater than 0', 'Molar Mass'));\r\n                    inputsAcceptable = false;\r\n                }\r\n\r\n                if (massAcceptable && percentAcceptable && percentsSumValid && molar_massAcceptable)\r\n                {\r\n                    const monomer = new Monomer(\r\n                        mass,\r\n                        weight_percent,\r\n                        mole_percent,\r\n                        molar_mass,\r\n                        // The last property (moles) defaults to 0 because it will be calculated at its calculation route\r\n                        0\r\n                    );\r\n                    \r\n                    funcGroupMonomers.push({ data: monomer, isOK: inputsAcceptable });\r\n                } else\r\n                {\r\n                    const ERROR_MESSAGE = `One or multiple of the values given for the ${monomerName} monomer is missing or invalid.`;\r\n                    console.error(ERROR_MESSAGE);\r\n                    inputsAcceptable = false;\r\n                    funcGroupMonomers.push({ message: ERROR_MESSAGE, isOK: inputsAcceptable });\r\n                }\r\n            }\r\n\r\n            // Add this functional group's monomers to the parseMonomers array\r\n            return funcGroupMonomers;\r\n        });\r\n        \r\n        console.log('Parsed funcGroups: ', parsedMonomers);\r\n        console.log('Reducer State: ', funcGroups);\r\n\r\n        const validateMonomers = (monomers) => {\r\n            return monomers.reduce((validatedMonomers, monomer) => {\r\n                if (monomer.isOK)\r\n                    validatedMonomers.push(monomer.data);\r\n                \r\n                return validatedMonomers;\r\n            }, []);\r\n        }\r\n\r\n        // Check that all monomers are valid by filtering out any which are not acceptable\r\n        const [ monomersFuncA, monomersFuncB ] = parsedMonomers;\r\n        const validMonomersFuncA = validateMonomers(monomersFuncA);\r\n        const validMonomersFuncB = validateMonomers(monomersFuncB);\r\n        const validMonomers = [validMonomersFuncA, validMonomersFuncB];\r\n        \r\n        // Evaluate if the monomers for each functional group are valid\r\n        const [ funcA, funcB ] = funcGroups;\r\n        const funcA_monomersOK = validMonomersFuncA.length === funcA.getNum();\r\n        const funcB_monomersOK = validMonomersFuncB.length === funcB.getNum();\r\n        \r\n        if (funcA_monomersOK && funcB_monomersOK)\r\n        {\r\n            // Update the Functional Group Context with the validated monomer data\r\n            setFuncGroup({ type: UPDATE_MONOMERS, 'funcGroups': { monomers: validMonomers } });\r\n        }\r\n        // Only the monomers for functional group A were invalid\r\n        else if (funcA_monomersOK)\r\n            console.error(Error('One of the monomers for Functional Group A was given invalid input. Please try again.'));\r\n        // Only the monomers for functional group B were invalid\r\n        else if (funcB_monomersOK)\r\n            console.error(Error('One of the monomers for Functional Group B was given invalid input. Please try again.'));\r\n        else\r\n            console.error(Error('One of the monomers was given invalid input. Please try again.'));\r\n\r\n    }\r\n\r\n    React.useEffect(() => {\r\n        if (funcGroups.length > 0)\r\n        {\r\n            const [ funcA, funcB ] = funcGroups;\r\n            const monomersDefined = funcA.monomers.length > 0 && funcB.monomers.length > 0;\r\n            \r\n            // All necessary information has been given, so display final results\r\n            if (monomersDefined) {\r\n                // Start Data Sorting: returns updated functional groups with monomer stat counts in addition to calculation routes for functional groups\r\n                const routes = startDataSorting(funcGroups);\r\n\r\n                if (!routes) {\r\n                    console.error(Error(`There was a problem finding one of the calculation routes`));\r\n                }\r\n                else {\r\n                    const [ funcA_route, funcB_route ] = routes;\r\n\r\n                    if (funcA.isReference) {\r\n                        // Func Group A is reference, Func Group B is complimentary\r\n                        const refCalculationsSuccessful = doReferenceCalculations(funcA, funcA_route);\r\n                        if (refCalculationsSuccessful) {\r\n                            const compCalculationsSuccessful = doComplimentaryCalculations(funcA, funcB, funcB_route);\r\n\r\n                            if (compCalculationsSuccessful) {\r\n                                // Display Final Results\r\n                                setPage({ page: FINAL_RESULTS });\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (funcB.isReference) {\r\n                        // Func Group B is reference, Func Group A is complimentary\r\n                        const refCalculationsSuccessful = doReferenceCalculations(funcB, funcB_route);\r\n                        if (refCalculationsSuccessful) {\r\n                            const compCalculationsSuccessful = doComplimentaryCalculations(funcB, funcA, funcA_route);\r\n\r\n                            if (compCalculationsSuccessful) {\r\n                                // Display Final Results\r\n                                setPage({ page: FINAL_RESULTS });\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // No reference group for either functional group\r\n                        console.error(Error(`No valid reference group`));\r\n                    }\r\n                }\r\n            } \r\n        }\r\n        else\r\n        {\r\n            // Func Groups were reset, so return to Func Group Form\r\n            setPage({ page: FUNC_FORM });\r\n        }\r\n    }, [funcGroups, setPage]);\r\n\r\n    const backToFuncForm = () => {\r\n        setFuncGroup({ type: UPDATE_FUNC, funcGroups: [] });\r\n    }\r\n    \r\n    return (\r\n        <div className=\"form_container\">\r\n            <div id=\"monomer_data_entry\" className=\"dynamic_form\">\r\n                {funcGroups.map(({ name, num, percent_type }) => {\r\n                    const funcName = capitalizeFirstLetter(name);\r\n\r\n                    return (\r\n                    <form key={`${name}_entry`} name={`${name}_entry`} id={`${name}_entry`}>\r\n                        <h2 className='dyn_heading'>{funcName} Group</h2>\r\n                        <section className=\"ag_box\">\r\n                            <h3 className='ag_box_dyn_heading'>{funcName} Group</h3>\r\n                            {Array.from({ length: num }, (monomer, index) =>\r\n                                <div key={`${name}-${index + 1}`}>\r\n                                    {/* Mass Input Field */}\r\n                                    <label htmlFor={`mass${funcName}-${index + 1}`}>Mass (g)</label>\r\n                                    <input \r\n                                        type=\"text\" \r\n                                        name={`mass${funcName}-${index + 1}`} \r\n                                        value={formData.monomersForm[`mass${funcName}-${index + 1}`]}\r\n                                        onChange={handleFormChange}\r\n                                        className=\"dyn_input_field\"\r\n                                    />\r\n\r\n                                    {/* Percent Input Field */}\r\n                                    <label htmlFor={`percent${funcName}-${index + 1}`}>{`${capitalizeFirstLetter(percent_type)} Percent (%)`}</label>\r\n                                    <input \r\n                                        type=\"text\" \r\n                                        name={`percent${funcName}-${index + 1}`} \r\n                                        // Disable percent input and display 100 if there is only one monomer\r\n                                        disabled={num === 1}\r\n                                        placeholder={ num === 1 ? '100' : '' }\r\n                                        value={num === 1 ? '100' : formData.monomersForm[`percent${funcName}-${index + 1}`]}\r\n                                        onChange={handleFormChange}\r\n                                        className=\"dyn_input_field\"\r\n                                    />\r\n\r\n                                    {/* Molar Mass Input Field */}\r\n                                    <label htmlFor={`molar_mass${funcName}-${index + 1}`}>Molar Mass (g/mol)</label>\r\n                                    <input \r\n                                        type=\"text\" \r\n                                        name={`molar_mass${funcName}-${index + 1}`} \r\n                                        value={formData.monomersForm[`molar_mass${funcName}-${index + 1}`]}\r\n                                        onChange={handleFormChange}\r\n                                        className=\"dyn_input_field\" \r\n                                    />\r\n\r\n                                    <br />\r\n                                </div>\r\n                            )}\r\n                        </section>\r\n                    </form>\r\n                    )\r\n                })}\r\n                <div id='monomer_submit_container' className='submit_container'>\r\n                    <button type='button' onClick={() => backToFuncForm()} className='back_button'>Back</button>\r\n                    <button type='button' onClick={() => handleFormSubmission()} className='submit_button'>Next</button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}","import React from 'react';\r\nimport { useFuncGroups, useFuncDispatch } from '../contexts/FuncContext';\r\nimport { UPDATE_FUNC } from '../contexts/actions';\r\nimport { MONOMER_FORM } from '../contexts/page_names';\r\nimport { capitalizeFirstLetter } from '../utils/ornaments';\r\n\r\nexport default function FinalResults()\r\n{\r\n    const { funcGroups } = useFuncGroups();\r\n    const { setFuncGroup, setPage } = useFuncDispatch();\r\n\r\n    React.useEffect(() => {\r\n        const [ funcA, funcB ] = funcGroups;\r\n        const funcA_monomersReset = funcA.getMonomers().length === 0;\r\n        const funcB_monomersReset = funcB.getMonomers().length === 0;\r\n        \r\n        if (funcA_monomersReset && funcB_monomersReset)\r\n        {\r\n            // Monomers were reset, so return to Monomers Form\r\n            setPage({ page: MONOMER_FORM });\r\n        }\r\n    }, [funcGroups, setPage]);\r\n\r\n    const resetFuncCalculations = () => {\r\n        const [ funcA, funcB ] = funcGroups;\r\n\r\n        // Resets functional group monomers to allow new calculations\r\n        funcA.clearMonomers();\r\n        funcB.clearMonomers();\r\n\r\n        // Update the Functional Group Context with the reset monomer data\r\n        setFuncGroup({ type: UPDATE_FUNC, 'funcGroups': [funcA, funcB] });\r\n    }\r\n\r\n    return (\r\n        <div className=\"form_container\">\r\n            <div className='final_results'>\r\n                {funcGroups.map(({ name, monomers }) => \r\n                    <section id={`${name}_results`} className=\"dynamic_form\" key={`${name}_results`}>\r\n                        <h2 className='group_heading'>{capitalizeFirstLetter(name)} Heading</h2>\r\n                        <section className='ag_box'>\r\n                            <table className='final_results'>\r\n                                <thead>\r\n                                    <tr>\r\n                                        <th id={`${name}_th`}>Monomer</th>\r\n                                        <th id={`${name}_mass`}>Mass (g)</th>\r\n                                        <th id={`${name}_wpercent`}>Weight Percent (%)</th>\r\n                                        <th id={`${name}_mpercent`}>Mole Percent (%)</th>\r\n                                        <th id={`${name}_molar_mass`}>Molar Mass (g/mol)</th>\r\n                                        <th id={`${name}_moles`}>Moles (mol)</th>\r\n                                    </tr>\r\n                                </thead>\r\n                                <tbody>\r\n                                    {monomers.map((monomer, monomer_num) => \r\n                                        <tr className='monomer_row' key={`${name}_row${monomer_num}`}>\r\n                                            <td>{`${capitalizeFirstLetter(name)} ${monomer_num + 1}`}</td>\r\n                                            <td>{monomer.display('mass')}</td>\r\n                                            <td>{monomer.display('wpercent')}</td>\r\n                                            <td>{monomer.display('mpercent')}</td>\r\n                                            <td>{monomer.display('molar_mass')}</td>\r\n                                            <td>{monomer.display('moles')}</td>\r\n                                        </tr>\r\n                                    )}\r\n                                </tbody>\r\n                            </table>\r\n                        </section>\r\n                    </section>\r\n                )}\r\n            </div>\r\n            <div id='monomer_submit_container' className='submit_container'>\r\n                <button type='button' onClick={resetFuncCalculations} className='back_button'>Back</button>\r\n            </div>\r\n        </div>\r\n    );\r\n}","import '../assets/main_style.css';\r\nimport WelcomeBanner from '../components/WelcomeBanner';\r\nimport FuncGroupForm from '../components/forms/FuncGroupForm';\r\nimport MonomerForm from '../components/forms/MonomerForm';\r\nimport FinalResults from '../components/FinalResults';\r\n// Track and set which page is displayed\r\nimport { useFuncGroups } from '../contexts/FuncContext';\r\nimport { FUNC_FORM, MONOMER_FORM, FINAL_RESULTS } from '../contexts/page_names';\r\n\r\nconst handlePageChange = (selected_page) => {\r\n    switch (selected_page)\r\n    {\r\n        case FUNC_FORM:     return <FuncGroupForm />\r\n        case MONOMER_FORM:  return <MonomerForm />\r\n        case FINAL_RESULTS: return <FinalResults />\r\n        // Invalid page selected\r\n        default:            throw Error('Invalid page: ', selected_page);\r\n    } \r\n}\r\n\r\nexport default function Main()\r\n{\r\n    const { page } = useFuncGroups();\r\n\r\n    return(\r\n        <main>\r\n            <WelcomeBanner />\r\n            {handlePageChange(page)}\r\n        </main>\r\n    )\r\n}","import Main from './pages/Main';\r\nimport FuncProvider from './contexts/FuncContext';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <FuncProvider>\r\n      \t<Main />\r\n    </FuncProvider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom/client';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById('root'));\r\nroot.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>\r\n);\r\n"],"sourceRoot":""}